/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["TETTE"] = factory();
	else
		root["TETTE"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./TETTE_CORE/core/controls/keyboardControl.js":
/*!*****************************************************!*\
  !*** ./TETTE_CORE/core/controls/keyboardControl.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KeyboardControl: () => (/* binding */ KeyboardControl)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar KeyboardControl = /*#__PURE__*/function () {\n  function KeyboardControl() {\n    _classCallCheck(this, KeyboardControl);\n    this.keysPressed = {};\n    this.initEventListeners();\n  }\n  return _createClass(KeyboardControl, [{\n    key: \"initEventListeners\",\n    value: function initEventListeners() {\n      var _this = this;\n      window.addEventListener('keydown', function (e) {\n        _this.keysPressed[e.key] = true;\n      });\n      window.addEventListener('keyup', function (e) {\n        _this.keysPressed[e.key] = false;\n      });\n    }\n  }, {\n    key: \"isKeyPressed\",\n    value: function isKeyPressed(key) {\n      return this.keysPressed[key] || false;\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/core/controls/keyboardControl.js?");

/***/ }),

/***/ "./TETTE_CORE/core/controls/mouseControl.js":
/*!**************************************************!*\
  !*** ./TETTE_CORE/core/controls/mouseControl.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MouseControl: () => (/* binding */ MouseControl)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar MouseControl = /*#__PURE__*/function () {\n  function MouseControl(canvas) {\n    _classCallCheck(this, MouseControl);\n    this.mousePosition = {\n      x: 0,\n      y: 0\n    };\n    this.isClicked = false;\n    this.setupMouseControls(canvas);\n  }\n  return _createClass(MouseControl, [{\n    key: \"setupMouseControls\",\n    value: function setupMouseControls(canvas) {\n      var _this = this;\n      canvas.addEventListener('mousemove', function (event) {\n        _this.mousePosition = {\n          x: event.clientX,\n          y: event.clientY\n        };\n      });\n      canvas.addEventListener('mousedown', function () {\n        _this.isClicked = true;\n      });\n      canvas.addEventListener('mouseup', function () {\n        _this.isClicked = false;\n      });\n    }\n  }, {\n    key: \"getMousePosition\",\n    value: function getMousePosition() {\n      return this.mousePosition;\n    }\n  }, {\n    key: \"isMouseClicked\",\n    value: function isMouseClicked() {\n      return this.isClicked;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      // Логика для обновления состояния мыши\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/core/controls/mouseControl.js?");

/***/ }),

/***/ "./TETTE_CORE/core/controls/touchControl.js":
/*!**************************************************!*\
  !*** ./TETTE_CORE/core/controls/touchControl.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TouchControl: () => (/* binding */ TouchControl)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar TouchControl = /*#__PURE__*/function () {\n  function TouchControl(canvas) {\n    _classCallCheck(this, TouchControl);\n    this.touchPosition = {\n      x: 0,\n      y: 0\n    };\n    this.isTouched = false;\n    this.setupTouchControls(canvas);\n  }\n  return _createClass(TouchControl, [{\n    key: \"setupTouchControls\",\n    value: function setupTouchControls(canvas) {\n      var _this = this;\n      canvas.addEventListener('touchstart', function (event) {\n        var touch = event.touches[0];\n        _this.touchPosition = {\n          x: touch.clientX,\n          y: touch.clientY\n        };\n        _this.isTouched = true;\n      });\n      canvas.addEventListener('touchmove', function (event) {\n        var touch = event.touches[0];\n        _this.touchPosition = {\n          x: touch.clientX,\n          y: touch.clientY\n        };\n      });\n      canvas.addEventListener('touchend', function () {\n        _this.isTouched = false;\n      });\n    }\n  }, {\n    key: \"getTouchPosition\",\n    value: function getTouchPosition() {\n      return this.touchPosition;\n    }\n  }, {\n    key: \"isTouchActive\",\n    value: function isTouchActive() {\n      return this.isTouched;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      // Логика для обновления состояния тачскрина\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/core/controls/touchControl.js?");

/***/ }),

/***/ "./TETTE_CORE/core/core_logic/ColorMixin.js":
/*!**************************************************!*\
  !*** ./TETTE_CORE/core/core_logic/ColorMixin.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColorMixin: () => (/* binding */ ColorMixin)\n/* harmony export */ });\nfunction ColorMixin(color, renderType) {\n  // Обработка для 2D Canvas\n  if (renderType === '2d') {\n    if (typeof color === 'string') {\n      if (color in colorNames) {\n        return colorNames[color]; // Преобразуем название цвета в HEX, если оно присутствует в словаре\n      }\n      return color; // Если это строка HEX или RGB, возвращаем её без изменений\n    }\n    throw new Error('Unsupported color format for Canvas: ' + color);\n  }\n\n  // Обработка для WebGL и WebGPU (нормализованные RGB значения)\n  if (renderType === 'webgl' || renderType === 'webgpu') {\n    // Если это строка в формате 'rgb(51, 51, 51)'\n    if (typeof color === 'string' && color.startsWith('rgb(')) {\n      return parseRgbString(color);\n    }\n\n    // Если это строка с именем цвета или HEX\n    if (typeof color === 'string') {\n      if (color in colorNames) {\n        color = colorNames[color]; // Преобразуем словесное имя цвета в HEX\n      }\n\n      // Если это HEX (#333 или #333333)\n      if (color[0] === '#') {\n        return hexToRgb(color);\n      }\n    }\n\n    // Если это массив RGB [r, g, b], нормализуем его для WebGL/WebGPU\n    if (Array.isArray(color)) {\n      return color.map(function (c) {\n        return c / 255;\n      });\n    }\n    throw new Error('Unsupported color format for WebGL/WebGPU: ' + color);\n  }\n  throw new Error('Unsupported render type: ' + renderType);\n}\n\n// Конвертация строки 'rgb(51, 51, 51)' в массив нормализованных RGB (0-1)\nfunction parseRgbString(rgbString) {\n  var rgbValues = rgbString.match(/\\d+/g).map(Number);\n  return rgbValues.map(function (value) {\n    return value / 255;\n  }); // Нормализуем значения\n}\n\n// Конвертация HEX-цвета в нормализованный RGB (0-1)\nfunction hexToRgb(hex) {\n  if (hex.length === 4) {\n    // Преобразуем короткий HEX формат (#333) в длинный формат (#333333)\n    hex = '#' + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];\n  }\n  var bigint = parseInt(hex.slice(1), 16);\n  var r = (bigint >> 16 & 255) / 255;\n  var g = (bigint >> 8 & 255) / 255;\n  var b = (bigint & 255) / 255;\n  return [r, g, b];\n}\n\n// Словесные названия цветов\nvar colorNames = {\n  black: '#000000',\n  white: '#FFFFFF',\n  red: '#FF0000',\n  green: '#00FF00',\n  blue: '#0000FF',\n  gray: '#808080',\n  yellow: '#FFFF00'\n  // Можно добавить дополнительные цвета по мере необходимости\n};\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/core/core_logic/ColorMixin.js?");

/***/ }),

/***/ "./TETTE_CORE/core/core_logic/Core.js":
/*!********************************************!*\
  !*** ./TETTE_CORE/core/core_logic/Core.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Core: () => (/* binding */ Core)\n/* harmony export */ });\n/* harmony import */ var _GraphicalContext_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GraphicalContext.js */ \"./TETTE_CORE/core/core_logic/GraphicalContext.js\");\n/* harmony import */ var _GameTypeFactory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameTypeFactory.js */ \"./TETTE_CORE/core/core_logic/GameTypeFactory.js\");\n/* harmony import */ var _ColorMixin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ColorMixin.js */ \"./TETTE_CORE/core/core_logic/ColorMixin.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// Core.js\n\n\n\nvar Core = /*#__PURE__*/function () {\n  function Core(_ref) {\n    var canvasId = _ref.canvasId,\n      _ref$renderType = _ref.renderType,\n      renderType = _ref$renderType === void 0 ? '2d' : _ref$renderType,\n      _ref$backgroundColor = _ref.backgroundColor,\n      backgroundColor = _ref$backgroundColor === void 0 ? 'black' : _ref$backgroundColor,\n      sceneManager = _ref.sceneManager,\n      _ref$width = _ref.width,\n      width = _ref$width === void 0 ? 900 : _ref$width,\n      _ref$height = _ref.height,\n      height = _ref$height === void 0 ? 600 : _ref$height;\n    _classCallCheck(this, Core);\n    var normalizedBackgroundColor = (0,_ColorMixin_js__WEBPACK_IMPORTED_MODULE_2__.ColorMixin)(backgroundColor, renderType);\n\n    // Инициализация графического контекста и рендерера\n    this.graphicalContext = new _GraphicalContext_js__WEBPACK_IMPORTED_MODULE_0__.GraphicalContext(canvasId, renderType, normalizedBackgroundColor, width, height);\n    this.renderer = this.graphicalContext.getRenderer(); // Получаем рендерер из графического контекста\n    this.sceneManager = sceneManager;\n    this.lastTime = 0;\n    this.loop = this.loop.bind(this); // Привязываем метод loop к текущему контексту\n    this.gameTypeInstance = null;\n  }\n\n  // Устанавливаем тип игры\n  return _createClass(Core, [{\n    key: \"setGameType\",\n    value: function setGameType(gameType) {\n      if (gameType) {\n        console.log(\"\\u0423\\u0441\\u0442\\u0430\\u043D\\u043E\\u0432\\u043A\\u0430 \\u0442\\u0438\\u043F\\u0430 \\u0438\\u0433\\u0440\\u044B: \".concat(gameType));\n        this.gameTypeInstance = new _GameTypeFactory_js__WEBPACK_IMPORTED_MODULE_1__.GameTypeFactory(this).loadGameType(gameType); // Загружаем тип игры\n        if (!this.gameTypeInstance) {\n          console.error(\"\\u041E\\u0448\\u0438\\u0431\\u043A\\u0430: \\u0442\\u0438\\u043F \\u0438\\u0433\\u0440\\u044B \".concat(gameType, \" \\u043D\\u0435 \\u0437\\u0430\\u0433\\u0440\\u0443\\u0436\\u0435\\u043D.\"));\n        }\n      }\n    }\n\n    // Старт игрового цикла\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(typeof this.renderer.init === 'function')) {\n                _context.next = 3;\n                break;\n              }\n              _context.next = 3;\n              return this.renderer.init();\n            case 3:\n              // Запуск типа игры, если он определен\n              if (this.gameTypeInstance && typeof this.gameTypeInstance.start === 'function') {\n                this.gameTypeInstance.start();\n              }\n\n              // Запуск игрового цикла\n              requestAnimationFrame(this.loop);\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function start() {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }() // Основной игровой цикл\n  }, {\n    key: \"loop\",\n    value: function loop(timestamp) {\n      var deltaTime = timestamp - this.lastTime; // Рассчитываем дельту времени между кадрами\n      this.lastTime = timestamp;\n\n      // Обновляем тип игры (если он установлен)\n      if (this.gameTypeInstance && this.gameTypeInstance.update) {\n        this.gameTypeInstance.update(deltaTime);\n      }\n\n      // Обновляем менеджер сцен\n      this.sceneManager.update(deltaTime);\n\n      // Рендерим текущую сцену через SceneManager\n      this.renderer.clear(); // Очищаем экран\n      this.sceneManager.render(this.renderer.context); // Рендерим сцену\n      // Продолжаем цикл\n      requestAnimationFrame(this.loop);\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/core/core_logic/Core.js?");

/***/ }),

/***/ "./TETTE_CORE/core/core_logic/GameTypeFactory.js":
/*!*******************************************************!*\
  !*** ./TETTE_CORE/core/core_logic/GameTypeFactory.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameTypeFactory: () => (/* binding */ GameTypeFactory)\n/* harmony export */ });\n/* harmony import */ var _gameTypePresets_PlatformerGameType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../gameTypePresets/PlatformerGameType.js */ \"./TETTE_CORE/gameTypePresets/PlatformerGameType.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// GameTypeFactory.js\n\n// Добавьте другие типы игр по необходимости\n\nvar GameTypeFactory = /*#__PURE__*/function () {\n  function GameTypeFactory(core) {\n    _classCallCheck(this, GameTypeFactory);\n    this.core = core;\n  }\n  return _createClass(GameTypeFactory, [{\n    key: \"loadGameType\",\n    value: function loadGameType(gameType) {\n      console.log(\"\\u0417\\u0430\\u0433\\u0440\\u0443\\u0437\\u043A\\u0430 \\u0442\\u0438\\u043F\\u0430 \\u0438\\u0433\\u0440\\u044B: \".concat(gameType)); // Отладочный вывод\n      switch (gameType) {\n        case 'platformer':\n          console.log(this.core);\n          console.log(\"\\u0421\\u043E\\u0437\\u0434\\u0430\\u043D\\u0438\\u0435 \\u044D\\u043A\\u0437\\u0435\\u043C\\u043F\\u043B\\u044F\\u0440\\u0430 PlatformerGameType \\u0434\\u043B\\u044F: \".concat(gameType));\n          return new _gameTypePresets_PlatformerGameType_js__WEBPACK_IMPORTED_MODULE_0__.PlatformerGameType(this.core);\n        // Добавьте другие типы игр по необходимости\n        default:\n          console.warn(\"\\u041D\\u0435\\u0438\\u0437\\u0432\\u0435\\u0441\\u0442\\u043D\\u044B\\u0439 \\u0442\\u0438\\u043F \\u0438\\u0433\\u0440\\u044B: \".concat(gameType));\n          return null;\n      }\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/core/core_logic/GameTypeFactory.js?");

/***/ }),

/***/ "./TETTE_CORE/core/core_logic/GraphicalContext.js":
/*!********************************************************!*\
  !*** ./TETTE_CORE/core/core_logic/GraphicalContext.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GraphicalContext: () => (/* binding */ GraphicalContext)\n/* harmony export */ });\n/* harmony import */ var _renderers_CanvasRenderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderers/CanvasRenderer.js */ \"./TETTE_CORE/core/renderers/CanvasRenderer.js\");\n/* harmony import */ var _renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderers/WebGLRenderer.js */ \"./TETTE_CORE/core/renderers/WebGLRenderer.js\");\n/* harmony import */ var _renderers_WebGPURenderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderers/WebGPURenderer.js */ \"./TETTE_CORE/core/renderers/WebGPURenderer.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\nvar GraphicalContext = /*#__PURE__*/function () {\n  function GraphicalContext() {\n    var canvasId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'canvas';\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '2d';\n    var backgroundColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'black';\n    var width = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 900;\n    var height = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 600;\n    _classCallCheck(this, GraphicalContext);\n    this.canvas = document.getElementById(canvasId);\n    if (!this.canvas) {\n      throw new Error(\"Canvas with id \".concat(canvasId, \" not found!\"));\n    }\n\n    // Установка размеров канваса\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.context = this.initializeContext(type);\n    this.renderer = this.createRenderer(type, backgroundColor); // Передаем цвет фона\n  }\n  return _createClass(GraphicalContext, [{\n    key: \"initializeContext\",\n    value: function initializeContext(type) {\n      if (type === '2d') {\n        return this.canvas.getContext('2d');\n      } else if (type === 'webgl') {\n        return this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');\n      } else if (type === 'webgpu') {\n        if (navigator.gpu) {\n          return this.canvas.getContext('webgpu');\n        } else {\n          throw new Error(\"WebGPU not supported on this browser.\");\n        }\n      } else {\n        throw new Error(\"Unsupported context type: \" + type);\n      }\n    }\n  }, {\n    key: \"createRenderer\",\n    value: function createRenderer(type, backgroundColor) {\n      if (type === '2d') {\n        return new _renderers_CanvasRenderer_js__WEBPACK_IMPORTED_MODULE_0__.CanvasRenderer(this, backgroundColor); // Передаем цвет фона\n      } else if (type === 'webgl') {\n        return new _renderers_WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_1__.WebGLRenderer(this, backgroundColor); // Передаем цвет фона\n      } else if (type === 'webgpu') {\n        return new _renderers_WebGPURenderer_js__WEBPACK_IMPORTED_MODULE_2__.WebGPURenderer(this, backgroundColor); // Передаем цвет фона\n      } else {\n        throw new Error('Unsupported render type: ' + type);\n      }\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.context;\n    }\n  }, {\n    key: \"getCanvas\",\n    value: function getCanvas() {\n      return this.canvas;\n    }\n  }, {\n    key: \"getRenderer\",\n    value: function getRenderer() {\n      return this.renderer; // Метод для получения рендерера\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/core/core_logic/GraphicalContext.js?");

/***/ }),

/***/ "./TETTE_CORE/core/core_logic/Renderer.js":
/*!************************************************!*\
  !*** ./TETTE_CORE/core/core_logic/Renderer.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Renderer: () => (/* binding */ Renderer)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar Renderer = /*#__PURE__*/function () {\n  function Renderer(graphicalContext) {\n    _classCallCheck(this, Renderer);\n    if ((this instanceof Renderer ? this.constructor : void 0) === Renderer) {\n      throw new TypeError('Cannot instantiate abstract class Renderer');\n    }\n    this.canvas = graphicalContext.getCanvas(); // Получаем canvas\n    this.context = graphicalContext.getContext(); // Получаем контекст\n  }\n\n  // Очищаем экран (реализуется в наследниках)\n  return _createClass(Renderer, [{\n    key: \"clear\",\n    value: function clear() {\n      throw new Error('Метод \"clear()\" должен быть реализован в подклассе.');\n    }\n\n    // Рендеринг сцены (реализуется в наследниках)\n  }, {\n    key: \"render\",\n    value: function render(scene) {\n      throw new Error('Метод \"render(scene)\" должен быть реализован в подклассе.');\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/core/core_logic/Renderer.js?");

/***/ }),

/***/ "./TETTE_CORE/core/core_logic/SceneManager.js":
/*!****************************************************!*\
  !*** ./TETTE_CORE/core/core_logic/SceneManager.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SceneManager: () => (/* binding */ SceneManager)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// SceneManager.js\nvar SceneManager = /*#__PURE__*/function () {\n  function SceneManager() {\n    _classCallCheck(this, SceneManager);\n    this.scenes = {};\n    this.currentScene = null;\n  }\n  return _createClass(SceneManager, [{\n    key: \"createScene\",\n    value: function createScene() {\n      var _this = this;\n      for (var _len = arguments.length, names = new Array(_len), _key = 0; _key < _len; _key++) {\n        names[_key] = arguments[_key];\n      }\n      names.forEach(function (name) {\n        if (!_this.scenes[name]) {\n          _this.scenes[name] = {\n            name: name,\n            gameObjects: []\n          };\n          console.log(\"\\u0421\\u0446\\u0435\\u043D\\u0430 \\\"\".concat(name, \"\\\" \\u0441\\u043E\\u0437\\u0434\\u0430\\u043D\\u0430.\"));\n        } else {\n          console.warn(\"\\u0421\\u0446\\u0435\\u043D\\u0430 \\\"\".concat(name, \"\\\" \\u0443\\u0436\\u0435 \\u0441\\u0443\\u0449\\u0435\\u0441\\u0442\\u0432\\u0443\\u0435\\u0442.\"));\n        }\n      });\n    }\n  }, {\n    key: \"changeScene\",\n    value: function changeScene(name) {\n      if (this.scenes[name]) {\n        this.currentScene = this.scenes[name];\n        console.log(\"\\u041F\\u0435\\u0440\\u0435\\u043A\\u043B\\u044E\\u0447\\u0435\\u043D\\u043E \\u043D\\u0430 \\u0441\\u0446\\u0435\\u043D\\u0443 \\\"\".concat(name, \"\\\".\"));\n      } else {\n        console.error(\"\\u0421\\u0446\\u0435\\u043D\\u0430 \\\"\".concat(name, \"\\\" \\u043D\\u0435 \\u0441\\u0443\\u0449\\u0435\\u0441\\u0442\\u0432\\u0443\\u0435\\u0442.\"));\n      }\n    }\n  }, {\n    key: \"addGameObjectToScene\",\n    value: function addGameObjectToScene(sceneName) {\n      var scene = this.scenes[sceneName];\n      if (scene) {\n        for (var _len2 = arguments.length, gameObjects = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          gameObjects[_key2 - 1] = arguments[_key2];\n        }\n        gameObjects.forEach(function (obj) {\n          if (!scene.gameObjects.includes(obj)) {\n            scene.gameObjects.push(obj);\n          } else {\n            console.warn(\"\\u041E\\u0431\\u044A\\u0435\\u043A\\u0442 \\u0443\\u0436\\u0435 \\u0434\\u043E\\u0431\\u0430\\u0432\\u043B\\u0435\\u043D \\u0432 \\u0441\\u0446\\u0435\\u043D\\u0443 \\\"\".concat(sceneName, \"\\\".\"));\n          }\n        });\n      } else {\n        console.error(\"\\u041D\\u0435\\u0432\\u043E\\u0437\\u043C\\u043E\\u0436\\u043D\\u043E \\u0434\\u043E\\u0431\\u0430\\u0432\\u0438\\u0442\\u044C \\u043E\\u0431\\u044A\\u0435\\u043A\\u0442 \\u0432 \\u043D\\u0435\\u0441\\u0443\\u0449\\u0435\\u0441\\u0442\\u0432\\u0443\\u044E\\u0449\\u0443\\u044E \\u0441\\u0446\\u0435\\u043D\\u0443: \\\"\".concat(sceneName, \"\\\".\"));\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(deltaTime) {\n      if (this.currentScene) {\n        this.currentScene.gameObjects.forEach(function (object) {\n          if (typeof object.update === \"function\") {\n            object.update(deltaTime);\n          }\n        });\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(context) {\n      if (this.currentScene) {\n        var sortedGameObjects = this.currentScene.gameObjects.sort(function (a, b) {\n          return a.layer - b.layer;\n        });\n\n        // Рендерим каждый объект\n        sortedGameObjects.forEach(function (object) {\n          if (typeof object.render === \"function\") {\n            object.render(context);\n          }\n        });\n      }\n    }\n  }, {\n    key: \"getCurrentScene\",\n    value: function getCurrentScene() {\n      return this.currentScene;\n    }\n  }, {\n    key: \"removeGameObjectFromScene\",\n    value: function removeGameObjectFromScene(sceneName, gameObject) {\n      var scene = this.scenes[sceneName];\n      if (scene) {\n        var index = scene.gameObjects.indexOf(gameObject);\n        if (index !== -1) {\n          scene.gameObjects.splice(index, 1);\n          console.log(\"\\u041E\\u0431\\u044A\\u0435\\u043A\\u0442 \\u0443\\u0434\\u0430\\u043B\\u0435\\u043D \\u0438\\u0437 \\u0441\\u0446\\u0435\\u043D\\u044B \\\"\".concat(sceneName, \"\\\".\"));\n        } else {\n          console.warn(\"\\u041E\\u0431\\u044A\\u0435\\u043A\\u0442 \\u043D\\u0435 \\u043D\\u0430\\u0439\\u0434\\u0435\\u043D \\u0432 \\u0441\\u0446\\u0435\\u043D\\u0435 \\\"\".concat(sceneName, \"\\\".\"));\n        }\n      } else {\n        console.error(\"\\u0421\\u0446\\u0435\\u043D\\u0430 \\\"\".concat(sceneName, \"\\\" \\u043D\\u0435 \\u0441\\u0443\\u0449\\u0435\\u0441\\u0442\\u0432\\u0443\\u0435\\u0442.\"));\n      }\n    }\n  }, {\n    key: \"getGameObjectsFromCurrentScene\",\n    value: function getGameObjectsFromCurrentScene() {\n      return this.currentScene ? this.currentScene.gameObjects : [];\n    }\n  }, {\n    key: \"getGameObjectsByType\",\n    value: function getGameObjectsByType(type) {\n      if (!this.currentScene) {\n        console.error(\"Текущая сцена не установлена.\");\n        return [];\n      }\n      return this.currentScene.gameObjects.filter(function (obj) {\n        return obj instanceof type;\n      });\n    }\n  }, {\n    key: \"getGameObjectById\",\n    value: function getGameObjectById(id) {\n      if (!this.currentScene) {\n        console.error(\"Текущая сцена не установлена.\");\n        return null;\n      }\n      return this.currentScene.gameObjects.find(function (obj) {\n        return obj.id === id;\n      }) || null;\n    }\n  }, {\n    key: \"clearScene\",\n    value: function clearScene(sceneName) {\n      if (this.scenes[sceneName]) {\n        this.scenes[sceneName].gameObjects = [];\n        console.log(\"\\u0421\\u0446\\u0435\\u043D\\u0430 \\\"\".concat(sceneName, \"\\\" \\u043E\\u0447\\u0438\\u0449\\u0435\\u043D\\u0430.\"));\n      } else {\n        console.error(\"\\u0421\\u0446\\u0435\\u043D\\u0430 \\\"\".concat(sceneName, \"\\\" \\u043D\\u0435 \\u0441\\u0443\\u0449\\u0435\\u0441\\u0442\\u0432\\u0443\\u0435\\u0442.\"));\n      }\n    }\n  }, {\n    key: \"changeToNextScene\",\n    value: function changeToNextScene() {\n      var _this$currentScene;\n      var sceneNames = Object.keys(this.scenes);\n      var currentIndex = sceneNames.indexOf((_this$currentScene = this.currentScene) === null || _this$currentScene === void 0 ? void 0 : _this$currentScene.name);\n      if (currentIndex !== -1 && currentIndex < sceneNames.length - 1) {\n        this.changeScene(sceneNames[currentIndex + 1]);\n      } else {\n        console.warn(\"Следующая сцена не найдена или вы находитесь в последней сцене.\");\n      }\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/core/core_logic/SceneManager.js?");

/***/ }),

/***/ "./TETTE_CORE/core/physics/PhysicsEngine.js":
/*!**************************************************!*\
  !*** ./TETTE_CORE/core/physics/PhysicsEngine.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsEngine: () => (/* binding */ PhysicsEngine)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// PhysicsEngine.js\nvar PhysicsEngine = /*#__PURE__*/function () {\n  function PhysicsEngine() {\n    var gravity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 9.8;\n    _classCallCheck(this, PhysicsEngine);\n    this.gravity = gravity;\n  }\n  return _createClass(PhysicsEngine, [{\n    key: \"updatePhysics\",\n    value: function updatePhysics(gameObjects, deltaTime) {\n      var _this = this;\n      gameObjects.forEach(function (gameObject) {\n        if (gameObject.rigidBody) {\n          _this.applyGravity(gameObject, deltaTime);\n          _this.applyMovement(gameObject, deltaTime);\n        }\n      });\n      gameObjects.forEach(function (gameObject) {\n        if (gameObject.rigidBody) {\n          var otherObjects = gameObjects.filter(function (obj) {\n            return obj !== gameObject && obj.rigidBody;\n          });\n          _this.checkCollisions(gameObject, otherObjects);\n        }\n      });\n    }\n  }, {\n    key: \"applyGravity\",\n    value: function applyGravity(gameObject, deltaTime) {\n      var rigidBody = gameObject.rigidBody;\n      if (!rigidBody || rigidBody.isStatic) return;\n      var deltaSeconds = deltaTime / 1000;\n      rigidBody.velocityY += this.gravity * deltaSeconds * 100;\n    }\n  }, {\n    key: \"applyMovement\",\n    value: function applyMovement(gameObject, deltaTime) {\n      var rigidBody = gameObject.rigidBody;\n      if (!rigidBody || rigidBody.isStatic) return;\n      var deltaSeconds = deltaTime / 1000;\n      rigidBody.velocityX *= rigidBody.friction;\n      rigidBody.velocityY *= rigidBody.friction;\n      rigidBody.x += rigidBody.velocityX * deltaSeconds;\n      rigidBody.y += rigidBody.velocityY * deltaSeconds;\n\n      // Обновляем позиции объекта\n      gameObject.x = rigidBody.x;\n      gameObject.y = rigidBody.y;\n    }\n  }, {\n    key: \"checkCollisions\",\n    value: function checkCollisions(gameObject, objects) {\n      var _this2 = this;\n      objects.forEach(function (otherObject) {\n        if (otherObject.rigidBody && _this2.isColliding(gameObject, otherObject)) {\n          _this2.resolveCollision(gameObject, otherObject);\n        }\n      });\n    }\n  }, {\n    key: \"isColliding\",\n    value: function isColliding(obj1, obj2) {\n      var rb1 = obj1.rigidBody;\n      var rb2 = obj2.rigidBody;\n      return rb1.x < rb2.x + rb2.width && rb1.x + rb1.width > rb2.x && rb1.y < rb2.y + rb2.height && rb1.y + rb1.height > rb2.y;\n    }\n  }, {\n    key: \"resolveCollision\",\n    value: function resolveCollision(gameObject, otherObject) {\n      var rb1 = gameObject.rigidBody;\n      var rb2 = otherObject.rigidBody;\n      if (rb2.isStatic) {\n        // Столкновение с статическим объектом (например, пол)\n        if (rb1.velocityY > 0) {\n          // Если объект падает\n          rb1.y = rb2.y - rb1.height; // Ставим объект на поверхность\n          rb1.velocityY = 0; // Обнуляем скорость падения\n          rb1.onGround = true;\n        }\n      } else {\n        // Обработка столкновений между подвижными объектами (если необходимо)\n      }\n\n      // Обновляем позиции объекта\n      gameObject.x = rb1.x;\n      gameObject.y = rb1.y;\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/core/physics/PhysicsEngine.js?");

/***/ }),

/***/ "./TETTE_CORE/core/physics/RigidBody2d.js":
/*!************************************************!*\
  !*** ./TETTE_CORE/core/physics/RigidBody2d.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RigidBody2d: () => (/* binding */ RigidBody2d)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\n// RigidBody2d.js\nvar RigidBody2d = /*#__PURE__*/_createClass(function RigidBody2d() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n    _ref$mass = _ref.mass,\n    mass = _ref$mass === void 0 ? 1 : _ref$mass,\n    _ref$friction = _ref.friction,\n    friction = _ref$friction === void 0 ? 0.9 : _ref$friction,\n    _ref$isStatic = _ref.isStatic,\n    isStatic = _ref$isStatic === void 0 ? false : _ref$isStatic;\n  _classCallCheck(this, RigidBody2d);\n  this.mass = mass;\n  this.friction = friction;\n  this.isStatic = isStatic;\n  this.velocityX = 0;\n  this.velocityY = 0;\n  this.onGround = false;\n  // Добавляем позиции и размеры\n  this.x = 0;\n  this.y = 0;\n  this.width = 0;\n  this.height = 0;\n});\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/core/physics/RigidBody2d.js?");

/***/ }),

/***/ "./TETTE_CORE/core/renderers/CanvasRenderer.js":
/*!*****************************************************!*\
  !*** ./TETTE_CORE/core/renderers/CanvasRenderer.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CanvasRenderer: () => (/* binding */ CanvasRenderer)\n/* harmony export */ });\n/* harmony import */ var _core_logic_Renderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core_logic/Renderer.js */ \"./TETTE_CORE/core/core_logic/Renderer.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\nvar CanvasRenderer = /*#__PURE__*/function (_Renderer) {\n  function CanvasRenderer(graphicalContext, backgroundColor) {\n    var _this;\n    _classCallCheck(this, CanvasRenderer);\n    // Удален цвет по умолчанию\n    _this = _callSuper(this, CanvasRenderer, [graphicalContext]);\n    _this.backgroundColor = backgroundColor; // Устанавливаем переданный цвет фона\n    if (!_this.backgroundColor) {\n      throw new Error('Background color is required for CanvasRenderer.'); // Ошибка, если цвет фона не передан\n    }\n    return _this;\n  }\n\n  // Очищаем экран и устанавливаем фон\n  _inherits(CanvasRenderer, _Renderer);\n  return _createClass(CanvasRenderer, [{\n    key: \"clear\",\n    value: function clear() {\n      // Заливаем фон\n      this.context.fillStyle = this.backgroundColor; // Используем переданный цвет фона\n      this.context.fillRect(0, 0, this.canvas.width, this.canvas.height); // Заливаем весь канвас\n    }\n\n    // Рендерим объекты сцены\n    // render(scene) {\n    //   console.log(\"sss\")\n    //   this.clear(); // Очищаем экран перед отрисовкой\n\n    //   // Рендерим объекты текущей сцены\n    //   if (scene && scene.gameObjects) {\n    //     scene.gameObjects.forEach(entity => {\n    //       this.drawEntity(entity);\n    //     });\n    //   } else {\n    //     console.error(\"No game objects found in the scene!\");\n    //   }\n    // }\n    // Рендеринг конкретного объекта\n  }, {\n    key: \"drawEntity\",\n    value: function drawEntity(entity) {\n      // Если объект имеет метод render, вызываем его\n      if (entity && typeof entity.render === 'function') {\n        entity.render(this.context);\n      } else {\n        console.error(\"Object does not have a render method!\");\n      }\n    }\n  }]);\n}(_core_logic_Renderer_js__WEBPACK_IMPORTED_MODULE_0__.Renderer);\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/core/renderers/CanvasRenderer.js?");

/***/ }),

/***/ "./TETTE_CORE/core/renderers/WebGLRenderer.js":
/*!****************************************************!*\
  !*** ./TETTE_CORE/core/renderers/WebGLRenderer.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebGLRenderer: () => (/* binding */ WebGLRenderer)\n/* harmony export */ });\n/* harmony import */ var _core_logic_Renderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core_logic/Renderer.js */ \"./TETTE_CORE/core/core_logic/Renderer.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\nvar WebGLRenderer = /*#__PURE__*/function (_Renderer) {\n  function WebGLRenderer(graphicalContext, backgroundColor) {\n    var _this;\n    _classCallCheck(this, WebGLRenderer);\n    _this = _callSuper(this, WebGLRenderer, [graphicalContext]);\n    _this.backgroundColor = backgroundColor;\n    if (!_this.backgroundColor) {\n      throw new Error('Background color is required for WebGLRenderer.');\n    }\n\n    // Инициализация WebGL\n    _this.initializeWebGL();\n\n    // Инициализация шейдеров\n    _this.initShaders();\n\n    // Создание матрицы проекции\n    _this.createProjectionMatrix();\n    return _this;\n  }\n  _inherits(WebGLRenderer, _Renderer);\n  return _createClass(WebGLRenderer, [{\n    key: \"initializeWebGL\",\n    value: function initializeWebGL() {\n      var _this$backgroundColor = _slicedToArray(this.backgroundColor, 3),\n        r = _this$backgroundColor[0],\n        g = _this$backgroundColor[1],\n        b = _this$backgroundColor[2];\n      this.context.clearColor(r, g, b, 1.0);\n      this.context.enable(this.context.DEPTH_TEST);\n      this.context.depthFunc(this.context.LEQUAL);\n\n      // Устанавливаем вьюпорт\n      this.context.viewport(0, 0, this.canvas.width, this.canvas.height);\n    }\n\n    // Конвертация HEX-цвета в нормализованные RGB\n  }, {\n    key: \"initShaders\",\n    value: function initShaders() {\n      // Исходный код вершинного шейдера\n      var vertexShaderSource = \"\\n      attribute vec2 aVertexPosition;\\n      attribute vec4 aVertexColor;\\n      uniform mat4 uTransform;\\n      uniform mat4 uProjection;\\n      varying lowp vec4 vColor;\\n\\n      void main(void) {\\n        vec4 position = vec4(aVertexPosition, 0.0, 1.0);\\n        gl_Position = uProjection * uTransform * position;\\n        vColor = aVertexColor;\\n      }\\n    \";\n\n      // Исходный код фрагментного шейдера\n      var fragmentShaderSource = \"\\n      varying lowp vec4 vColor;\\n\\n      void main(void) {\\n        gl_FragColor = vColor;\\n      }\\n    \";\n      var vertexShader = this.loadShader(this.context.VERTEX_SHADER, vertexShaderSource);\n      var fragmentShader = this.loadShader(this.context.FRAGMENT_SHADER, fragmentShaderSource);\n\n      // Создаем и связываем шейдерную программу\n      this.shaderProgram = this.context.createProgram();\n      this.context.attachShader(this.shaderProgram, vertexShader);\n      this.context.attachShader(this.shaderProgram, fragmentShader);\n      this.context.linkProgram(this.shaderProgram);\n\n      // Проверяем успешность создания программы\n      if (!this.context.getProgramParameter(this.shaderProgram, this.context.LINK_STATUS)) {\n        console.error('Не удалось инициализировать шейдерную программу: ' + this.context.getProgramInfoLog(this.shaderProgram));\n        return null;\n      }\n      this.context.useProgram(this.shaderProgram);\n\n      // Получаем расположение атрибутов\n      this.vertexPositionAttribute = this.context.getAttribLocation(this.shaderProgram, 'aVertexPosition');\n      this.context.enableVertexAttribArray(this.vertexPositionAttribute);\n      this.vertexColorAttribute = this.context.getAttribLocation(this.shaderProgram, 'aVertexColor');\n      this.context.enableVertexAttribArray(this.vertexColorAttribute);\n    }\n  }, {\n    key: \"createProjectionMatrix\",\n    value: function createProjectionMatrix() {\n      var canvasWidth = this.canvas.width;\n      var canvasHeight = this.canvas.height;\n      this.projectionMatrix = [2 / canvasWidth, 0, 0, 0, 0, -2 / canvasHeight, 0, 0, 0, 0, 1, 0, -1, 1, 0, 1];\n\n      // Передаем матрицу проекции в шейдер\n      var uProjection = this.context.getUniformLocation(this.shaderProgram, 'uProjection');\n      this.context.uniformMatrix4fv(uProjection, false, new Float32Array(this.projectionMatrix));\n    }\n  }, {\n    key: \"loadShader\",\n    value: function loadShader(type, source) {\n      var shader = this.context.createShader(type);\n      this.context.shaderSource(shader, source);\n      this.context.compileShader(shader);\n      if (!this.context.getShaderParameter(shader, this.context.COMPILE_STATUS)) {\n        console.error('Ошибка при компиляции шейдера:', this.context.getShaderInfoLog(shader));\n        this.context.deleteShader(shader);\n        return null;\n      }\n      return shader;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      // Очищаем буферы цвета и глубины\n      this.context.clear(this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT);\n    }\n  }, {\n    key: \"render\",\n    value: function render(scene) {\n      var _this2 = this;\n      this.clear();\n      if (scene && scene.gameObjects) {\n        scene.gameObjects.forEach(function (entity) {\n          _this2.drawEntity(entity);\n        });\n      } else {\n        console.error('No game objects found in the scene!');\n      }\n    }\n  }, {\n    key: \"drawEntity\",\n    value: function drawEntity(entity) {\n      // Если объект имеет метод renderWebGL, вызываем его\n      if (entity && typeof entity.renderWebGL === 'function') {\n        entity.renderWebGL(this.context, this.shaderProgram);\n      } else {\n        console.error('Object does not have a renderWebGL method!');\n      }\n    }\n  }]);\n}(_core_logic_Renderer_js__WEBPACK_IMPORTED_MODULE_0__.Renderer);\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/core/renderers/WebGLRenderer.js?");

/***/ }),

/***/ "./TETTE_CORE/core/renderers/WebGPURenderer.js":
/*!*****************************************************!*\
  !*** ./TETTE_CORE/core/renderers/WebGPURenderer.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebGPURenderer: () => (/* binding */ WebGPURenderer)\n/* harmony export */ });\n/* harmony import */ var _core_logic_Renderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core_logic/Renderer.js */ \"./TETTE_CORE/core/core_logic/Renderer.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n// WebGPURenderer.js\n\n\nvar WebGPURenderer = /*#__PURE__*/function (_Renderer) {\n  function WebGPURenderer(graphicalContext, backgroundColor) {\n    var _this;\n    _classCallCheck(this, WebGPURenderer);\n    _this = _callSuper(this, WebGPURenderer, [graphicalContext]);\n    _this.device = null;\n    _this.context = null;\n    _this.renderPassDescriptor = null;\n    _this.pipeline = null;\n    _this.isInitialized = false;\n    _this.backgroundColor = backgroundColor || [0, 0, 0, 1]; // Цвет фона по умолчанию\n    return _this;\n  }\n  _inherits(WebGPURenderer, _Renderer);\n  return _createClass(WebGPURenderer, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return this.initializeWebGPU();\n            case 2:\n              this.isInitialized = true;\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function init() {\n        return _init.apply(this, arguments);\n      }\n      return init;\n    }()\n  }, {\n    key: \"initializeWebGPU\",\n    value: function () {\n      var _initializeWebGPU = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var adapter, canvasFormat;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (navigator.gpu) {\n                _context2.next = 3;\n                break;\n              }\n              console.error('WebGPU не поддерживается в этом браузере.');\n              return _context2.abrupt(\"return\");\n            case 3:\n              _context2.next = 5;\n              return navigator.gpu.requestAdapter();\n            case 5:\n              adapter = _context2.sent;\n              if (adapter) {\n                _context2.next = 9;\n                break;\n              }\n              console.error('Не удалось получить адаптер GPU.');\n              return _context2.abrupt(\"return\");\n            case 9:\n              _context2.next = 11;\n              return adapter.requestDevice();\n            case 11:\n              this.device = _context2.sent;\n              // Получаем контекст WebGPU из canvas\n              this.context = this.canvas.getContext('webgpu');\n              if (this.context) {\n                _context2.next = 16;\n                break;\n              }\n              console.error('Не удалось получить WebGPU контекст из canvas.');\n              return _context2.abrupt(\"return\");\n            case 16:\n              // Настраиваем контекст\n              canvasFormat = navigator.gpu.getPreferredCanvasFormat();\n              this.context.configure({\n                device: this.device,\n                format: canvasFormat,\n                alphaMode: 'opaque'\n              });\n\n              // Создаем дескриптор рендер-прохода\n              this.renderPassDescriptor = {\n                colorAttachments: [{\n                  view: undefined,\n                  // Будет задано в методе render\n                  clearValue: {\n                    r: this.backgroundColor[0],\n                    g: this.backgroundColor[1],\n                    b: this.backgroundColor[2],\n                    a: this.backgroundColor[3]\n                  },\n                  loadOp: 'clear',\n                  storeOp: 'store'\n                }]\n              };\n\n              // Инициализируем шейдеры и пайплайн\n              _context2.next = 21;\n              return this.initPipeline(canvasFormat);\n            case 21:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function initializeWebGPU() {\n        return _initializeWebGPU.apply(this, arguments);\n      }\n      return initializeWebGPU;\n    }()\n  }, {\n    key: \"initPipeline\",\n    value: function () {\n      var _initPipeline = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(format) {\n        var vertexShaderCode, fragmentShaderCode, vertexModule, fragmentModule, pipelineLayout;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              // WGSL код вершинного шейдера\n              vertexShaderCode = \"\\n      @group(0) @binding(0)\\n      var<uniform> uProjection : mat4x4<f32>;\\n\\n      @group(0) @binding(1)\\n      var<uniform> uTransform : mat4x4<f32>;\\n\\n      struct VertexOutput {\\n        @builtin(position) Position : vec4<f32>,\\n        @location(0) vColor : vec4<f32>,\\n      };\\n\\n      @vertex\\n      fn main(\\n        @location(0) aPosition : vec2<f32>,\\n        @location(1) aColor : vec4<f32>\\n      ) -> VertexOutput {\\n        var output : VertexOutput;\\n        var position : vec4<f32> = vec4<f32>(aPosition, 0.0, 1.0);\\n        output.Position = uProjection * uTransform * position;\\n        output.vColor = aColor;\\n        return output;\\n      }\\n    \"; // WGSL код фрагментного шейдера\n              fragmentShaderCode = \"\\n      @fragment\\n      fn main(@location(0) vColor : vec4<f32>) -> @location(0) vec4<f32> {\\n        return vColor;\\n      }\\n    \"; // Создаем модули шейдеров\n              vertexModule = this.device.createShaderModule({\n                code: vertexShaderCode\n              });\n              fragmentModule = this.device.createShaderModule({\n                code: fragmentShaderCode\n              }); // Создаем BindGroupLayout для передачи униформ-переменных\n              this.bindGroupLayout = this.device.createBindGroupLayout({\n                entries: [{\n                  binding: 0,\n                  visibility: GPUShaderStage.VERTEX,\n                  buffer: {\n                    type: 'uniform'\n                  }\n                }, {\n                  binding: 1,\n                  visibility: GPUShaderStage.VERTEX,\n                  buffer: {\n                    type: 'uniform'\n                  }\n                }]\n              });\n\n              // Создаем PipelineLayout с использованием BindGroupLayout\n              pipelineLayout = this.device.createPipelineLayout({\n                bindGroupLayouts: [this.bindGroupLayout]\n              }); // Создаем графический пайплайн\n              this.pipeline = this.device.createRenderPipeline({\n                layout: pipelineLayout,\n                vertex: {\n                  module: vertexModule,\n                  entryPoint: 'main',\n                  buffers: [{\n                    // Описание буфера вершин\n                    arrayStride: 2 * 4,\n                    // 2 компоненты по 4 байта (float32)\n                    attributes: [{\n                      shaderLocation: 0,\n                      offset: 0,\n                      format: 'float32x2'\n                    }]\n                  }, {\n                    // Описание буфера цветов\n                    arrayStride: 4 * 4,\n                    // 4 компоненты по 4 байта (float32)\n                    attributes: [{\n                      shaderLocation: 1,\n                      offset: 0,\n                      format: 'float32x4'\n                    }]\n                  }]\n                },\n                fragment: {\n                  module: fragmentModule,\n                  entryPoint: 'main',\n                  targets: [{\n                    format: format\n                  }]\n                },\n                primitive: {\n                  topology: 'triangle-list',\n                  stripIndexFormat: undefined,\n                  frontFace: 'ccw',\n                  cullMode: 'none'\n                }\n              });\n\n              // Создаем матрицу проекции\n              this.createProjectionMatrix();\n            case 8:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function initPipeline(_x) {\n        return _initPipeline.apply(this, arguments);\n      }\n      return initPipeline;\n    }()\n  }, {\n    key: \"createProjectionMatrix\",\n    value: function createProjectionMatrix() {\n      var canvasWidth = this.canvas.width;\n      var canvasHeight = this.canvas.height;\n\n      // Ортографическая проекция\n      this.projectionMatrix = new Float32Array([2 / canvasWidth, 0, 0, 0, 0, -2 / canvasHeight, 0, 0, 0, 0, 1, 0, -1, 1, 0, 1]);\n\n      // Создаем буфер для матрицы проекции\n      this.projectionBuffer = this.device.createBuffer({\n        size: this.projectionMatrix.byteLength,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n      });\n      this.device.queue.writeBuffer(this.projectionBuffer, 0, this.projectionMatrix);\n    }\n  }, {\n    key: \"render\",\n    value: function render(scene) {\n      var _this2 = this;\n      if (!this.isInitialized) {\n        console.warn('WebGPURenderer еще не инициализирован.');\n        return;\n      }\n\n      // Проверяем наличие устройства и контекста перед рендерингом\n      if (!this.device || !this.context) {\n        console.error('WebGPU устройство или контекст не инициализированы.');\n        return;\n      }\n      // Получаем текущую текстуру из контекста\n      var textureView = this.context.getCurrentTexture().createView();\n      this.renderPassDescriptor.colorAttachments[0].view = textureView;\n\n      // Создаем командный энкодер\n      var commandEncoder = this.device.createCommandEncoder();\n\n      // Начинаем рендер-проход\n      var passEncoder = commandEncoder.beginRenderPass(this.renderPassDescriptor);\n\n      // Устанавливаем графический пайплайн\n      passEncoder.setPipeline(this.pipeline);\n\n      // Создаем общий BindGroup для матрицы проекции\n      this.bindGroupProjection = this.device.createBindGroup({\n        layout: this.bindGroupLayout,\n        entries: [{\n          binding: 0,\n          resource: {\n            buffer: this.projectionBuffer\n          }\n        }, {\n          binding: 1,\n          resource: {\n            buffer: this.projectionBuffer // Временно, заменится на буфер трансформации объекта\n          }\n        }]\n      });\n\n      // Отрисовываем каждый объект сцены\n      if (scene && scene.gameObjects) {\n        scene.gameObjects.forEach(function (entity) {\n          _this2.drawEntity(entity, passEncoder);\n        });\n      } else {\n        console.error('No game objects found in the scene!');\n      }\n\n      // Завершаем рендер-проход\n      passEncoder.end();\n\n      // Отправляем команды в очередь\n      var commandBuffer = commandEncoder.finish();\n      this.device.queue.submit([commandBuffer]);\n    }\n  }, {\n    key: \"drawEntity\",\n    value: function drawEntity(entity, passEncoder) {\n      // Если объект имеет метод renderWebGPU, вызываем его\n      if (entity && typeof entity.renderWebGPU === 'function') {\n        entity.renderWebGPU(this.device, passEncoder, this.bindGroupLayout, this.projectionBuffer);\n      } else {\n        console.error('Object does not have a renderWebGPU method!');\n      }\n    }\n  }]);\n}(_core_logic_Renderer_js__WEBPACK_IMPORTED_MODULE_0__.Renderer);\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/core/renderers/WebGPURenderer.js?");

/***/ }),

/***/ "./TETTE_CORE/gameObjects/characters/Character.js":
/*!********************************************************!*\
  !*** ./TETTE_CORE/gameObjects/characters/Character.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Character: () => (/* binding */ Character)\n/* harmony export */ });\n/* harmony import */ var _core_physics_RigidBody2d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/physics/RigidBody2d.js */ \"./TETTE_CORE/core/physics/RigidBody2d.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// Character.js\n\nvar Character = /*#__PURE__*/function () {\n  function Character(_ref) {\n    var x = _ref.x,\n      y = _ref.y,\n      width = _ref.width,\n      height = _ref.height,\n      color = _ref.color,\n      sprite = _ref.sprite,\n      _ref$animations = _ref.animations,\n      animations = _ref$animations === void 0 ? {} : _ref$animations,\n      _ref$health = _ref.health,\n      health = _ref$health === void 0 ? 100 : _ref$health,\n      _ref$speed = _ref.speed,\n      speed = _ref$speed === void 0 ? 30 : _ref$speed,\n      _ref$enablePhysics = _ref.enablePhysics,\n      enablePhysics = _ref$enablePhysics === void 0 ? false : _ref$enablePhysics,\n      _ref$layer = _ref.layer,\n      layer = _ref$layer === void 0 ? 1 : _ref$layer;\n    _classCallCheck(this, Character);\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.color = color;\n    this.health = health;\n    this.speed = speed;\n    this.currentFrameIndex = 0;\n    this.frameDuration = 100;\n    this.elapsedTime = 0;\n    this.facingDirection = 1;\n    this.layer = layer;\n\n    // Устанавливаем спрайт, если он есть\n    this.sprite = sprite ? new Image() : null;\n    if (this.sprite) {\n      this.sprite.src = sprite;\n    }\n\n    // Устанавливаем анимации\n    this.animations = {\n      idle: animations.idle || [],\n      run: animations.run || [],\n      jump: animations.jump || [],\n      attack: animations.attack || []\n    };\n    if (this.animations.idle.length === 0) {\n      this.animations.idle = this.animations.run;\n    }\n    this.currentAnimation = this.sprite ? null : 'idle';\n\n    // Загружаем изображения для анимаций\n    for (var key in this.animations) {\n      if (this.animations[key].length > 0) {\n        this.animations[key] = this.animations[key].map(function (src) {\n          var img = new Image();\n          img.src = src;\n          return img;\n        });\n      }\n    }\n\n    // Добавляем физику, если включена\n    if (enablePhysics) {\n      this.rigidBody = new _core_physics_RigidBody2d_js__WEBPACK_IMPORTED_MODULE_0__.RigidBody2d({\n        mass: 1,\n        friction: 0.9,\n        isStatic: false\n      });\n\n      // Инициализируем позиции\n      this.rigidBody.x = this.x;\n      this.rigidBody.y = this.y;\n      this.rigidBody.width = this.width;\n      this.rigidBody.height = this.height;\n    } else {\n      this.rigidBody = null;\n    }\n  }\n  return _createClass(Character, [{\n    key: \"setAnimation\",\n    value: function setAnimation(animationName) {\n      if (this.animations[animationName] && this.animations[animationName].length > 0) {\n        if (this.currentAnimation !== animationName) {\n          this.currentAnimation = animationName;\n          this.currentFrameIndex = 0;\n          this.elapsedTime = 0;\n        }\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(deltaTime) {\n      if (this.rigidBody) {\n        // Обновляем позиции из rigidBody, если физика включена\n        this.x = this.rigidBody.x;\n        this.y = this.rigidBody.y;\n\n        // Обновляем направление персонажа\n        if (this.rigidBody.velocityX > 0) {\n          this.facingDirection = 1;\n        } else if (this.rigidBody.velocityX < 0) {\n          this.facingDirection = -1;\n        }\n\n        // Обновляем анимации в зависимости от движения\n        if (!this.rigidBody.onGround) {\n          this.setAnimation('jump');\n        } else if (this.rigidBody.velocityX !== 0) {\n          this.setAnimation('run');\n        } else {\n          this.setAnimation('idle');\n        }\n      }\n\n      // Обновление кадров анимации\n      var activeFrames = this.currentAnimation ? this.animations[this.currentAnimation] : [];\n      if (activeFrames.length > 0) {\n        this.elapsedTime += deltaTime;\n        if (this.elapsedTime >= this.frameDuration) {\n          this.elapsedTime = 0;\n          this.currentFrameIndex = (this.currentFrameIndex + 1) % activeFrames.length;\n        }\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(context) {\n      context.save();\n\n      // Инвертируем изображение при движении влево\n      if (this.facingDirection === -1) {\n        context.translate(this.x + this.width / 2, this.y);\n        context.scale(-1, 1);\n        context.translate(-this.width / 2, 0);\n      } else {\n        context.translate(this.x, this.y);\n      }\n\n      // Рендерим спрайт или анимацию\n      if (this.sprite && this.sprite.complete) {\n        context.drawImage(this.sprite, 0, 0, this.width, this.height);\n      } else {\n        var activeFrames = this.currentAnimation ? this.animations[this.currentAnimation] : [];\n        if (activeFrames.length > 0 && activeFrames[this.currentFrameIndex].complete) {\n          context.drawImage(activeFrames[this.currentFrameIndex], 0, 0, this.width, this.height);\n        } else {\n          context.fillStyle = this.color;\n          context.fillRect(0, 0, this.width, this.height);\n        }\n      }\n      context.restore();\n    }\n  }, {\n    key: \"takeDamage\",\n    value: function takeDamage(amount) {\n      this.health -= amount;\n      if (this.health <= 0) {\n        this.die();\n      }\n    }\n  }, {\n    key: \"die\",\n    value: function die() {\n      console.log(\"Character died\");\n      // Логика смерти персонажа\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/gameObjects/characters/Character.js?");

/***/ }),

/***/ "./TETTE_CORE/gameObjects/characters/Enemy.js":
/*!****************************************************!*\
  !*** ./TETTE_CORE/gameObjects/characters/Enemy.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Enemy: () => (/* binding */ Enemy)\n/* harmony export */ });\n/* harmony import */ var _Character_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Character.js */ \"./TETTE_CORE/gameObjects/characters/Character.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, e, o, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), e, o); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(o, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n// Enemy.js\n\nvar Enemy = /*#__PURE__*/function (_Character) {\n  function Enemy(options) {\n    _classCallCheck(this, Enemy);\n    return _callSuper(this, Enemy, [_objectSpread(_objectSpread({}, options), {}, {\n      health: 50,\n      speed: 20\n    })]);\n  }\n  _inherits(Enemy, _Character);\n  return _createClass(Enemy, [{\n    key: \"update\",\n    value: function update(deltaTime) {\n      _superPropGet(Enemy, \"update\", this, 3)([deltaTime]); // Используем базовое обновление\n      // Добавьте уникальную логику обновления для врага, например, патрулирование\n      this.patrol();\n    }\n  }, {\n    key: \"patrol\",\n    value: function patrol() {\n      // Пример логики патрулирования для врага\n      if (this.x <= this.leftBoundary) {\n        this.rigidBody.velocityX = this.speed;\n        this.facingDirection = 1;\n      } else if (this.x + this.width >= this.rightBoundary) {\n        this.rigidBody.velocityX = -this.speed;\n        this.facingDirection = -1;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(context) {\n      _superPropGet(Enemy, \"render\", this, 3)([context]); // Вызов базового рендеринга\n    }\n  }]);\n}(_Character_js__WEBPACK_IMPORTED_MODULE_0__.Character);\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/gameObjects/characters/Enemy.js?");

/***/ }),

/***/ "./TETTE_CORE/gameObjects/characters/PlatformerPlayerCharacter.js":
/*!************************************************************************!*\
  !*** ./TETTE_CORE/gameObjects/characters/PlatformerPlayerCharacter.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlatformerPlayerCharacter: () => (/* binding */ PlatformerPlayerCharacter)\n/* harmony export */ });\n/* harmony import */ var _Character_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Character.js */ \"./TETTE_CORE/gameObjects/characters/Character.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, e, o, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), e, o); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(o, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n// PlatformerPlayerCharacter.js\n\nvar PlatformerPlayerCharacter = /*#__PURE__*/function (_Character) {\n  function PlatformerPlayerCharacter(options) {\n    var _this;\n    _classCallCheck(this, PlatformerPlayerCharacter);\n    _this = _callSuper(this, PlatformerPlayerCharacter, [_objectSpread(_objectSpread({}, options), {}, {\n      health: 100,\n      magic: 100,\n      shots: 10,\n      score: 0\n    })]);\n    _this.magic = options.magic || 100; // Магия для игрока\n    _this.shots = options.shots || 10; // Выстрелы игрока\n    return _this;\n  }\n  _inherits(PlatformerPlayerCharacter, _Character);\n  return _createClass(PlatformerPlayerCharacter, [{\n    key: \"update\",\n    value: function update(deltaTime) {\n      _superPropGet(PlatformerPlayerCharacter, \"update\", this, 3)([deltaTime]); // Используем базовое обновление\n      // Добавьте уникальную логику обновления для игрока, если нужно\n    }\n  }, {\n    key: \"render\",\n    value: function render(context) {\n      _superPropGet(PlatformerPlayerCharacter, \"render\", this, 3)([context]); // Вызов базового рендера\n      // Добавьте уникальную логику рендеринга для игрока, если нужно\n    }\n  }, {\n    key: \"shoot\",\n    value: function shoot() {\n      if (this.shots > 0) {\n        this.shots -= 1;\n        console.log(\"Выстрел произведен!\");\n      } else {\n        console.log(\"Нет патронов!\");\n      }\n    }\n  }, {\n    key: \"useMagic\",\n    value: function useMagic(amount) {\n      if (this.magic >= amount) {\n        this.magic -= amount;\n        console.log(\"Использована магия\");\n      } else {\n        console.log(\"Недостаточно магии\");\n      }\n    }\n  }]);\n}(_Character_js__WEBPACK_IMPORTED_MODULE_0__.Character);\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/gameObjects/characters/PlatformerPlayerCharacter.js?");

/***/ }),

/***/ "./TETTE_CORE/gameObjects/shapes/2d/BezierCurve.js":
/*!*********************************************************!*\
  !*** ./TETTE_CORE/gameObjects/shapes/2d/BezierCurve.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BezierCurve: () => (/* binding */ BezierCurve)\n/* harmony export */ });\n/* harmony import */ var _gameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gameObject.js */ \"./TETTE_CORE/gameObjects/shapes/gameObject.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\nvar BezierCurve = /*#__PURE__*/function (_GameObject) {\n  function BezierCurve(startX, startY, controlX1, controlY1, controlX2, controlY2, endX, endY) {\n    var _this;\n    var color = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 'black';\n    var widthline = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 1;\n    _classCallCheck(this, BezierCurve);\n    _this = _callSuper(this, BezierCurve, [startX, startY, 0, 0, color]);\n    _this.startX = startX;\n    _this.startY = startY;\n    _this.controlX1 = controlX1;\n    _this.controlY1 = controlY1;\n    _this.controlX2 = controlX2;\n    _this.controlY2 = controlY2;\n    _this.endX = endX;\n    _this.endY = endY;\n    _this.color = color;\n    _this.widthline = widthline;\n    return _this;\n  }\n  _inherits(BezierCurve, _GameObject);\n  return _createClass(BezierCurve, [{\n    key: \"render\",\n    value: function render(context) {\n      context.beginPath();\n      context.moveTo(this.startX, this.startY);\n      context.bezierCurveTo(this.controlX1, this.controlY1, this.controlX2, this.controlY2, this.endX, this.endY);\n      context.strokeStyle = this.color;\n      context.lineWidth = this.widthline;\n      context.stroke();\n      context.closePath();\n    }\n  }]);\n}(_gameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject);\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/gameObjects/shapes/2d/BezierCurve.js?");

/***/ }),

/***/ "./TETTE_CORE/gameObjects/shapes/2d/Circle.js":
/*!****************************************************!*\
  !*** ./TETTE_CORE/gameObjects/shapes/2d/Circle.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Circle: () => (/* binding */ Circle)\n/* harmony export */ });\n/* harmony import */ var _gameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gameObject.js */ \"./TETTE_CORE/gameObjects/shapes/gameObject.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\nvar Circle = /*#__PURE__*/function (_GameObject) {\n  function Circle(x, y, radius) {\n    var _this;\n    var startAngle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var endAngle = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2 * Math.PI;\n    var color = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'black';\n    var borderColor = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n    var borderWidth = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n    _classCallCheck(this, Circle);\n    _this = _callSuper(this, Circle, [x, y, radius * 2, radius * 2, color]);\n    _this.radius = radius;\n    _this.startAngle = startAngle;\n    _this.endAngle = endAngle;\n    _this.borderColor = borderColor;\n    _this.borderWidth = borderWidth;\n    return _this;\n  }\n\n  // Метод для рендеринга круга или дуги\n  _inherits(Circle, _GameObject);\n  return _createClass(Circle, [{\n    key: \"render\",\n    value: function render(context) {\n      context.beginPath();\n\n      // Рисуем дугу или круг в зависимости от углов\n      context.arc(this.x + this.radius, this.y + this.radius, this.radius, this.startAngle, this.endAngle);\n\n      // Основной цвет заливки\n      context.fillStyle = this.color;\n      context.fill();\n\n      // Если есть граница, рисуем её\n      if (this.borderColor) {\n        context.strokeStyle = this.borderColor;\n        context.lineWidth = this.borderWidth;\n        context.stroke();\n      }\n      context.closePath();\n    }\n  }]);\n}(_gameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject);\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/gameObjects/shapes/2d/Circle.js?");

/***/ }),

/***/ "./TETTE_CORE/gameObjects/shapes/2d/Ellipse.js":
/*!*****************************************************!*\
  !*** ./TETTE_CORE/gameObjects/shapes/2d/Ellipse.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ellipse: () => (/* binding */ Ellipse)\n/* harmony export */ });\n/* harmony import */ var _gameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gameObject.js */ \"./TETTE_CORE/gameObjects/shapes/gameObject.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\nvar Ellipse = /*#__PURE__*/function (_GameObject) {\n  function Ellipse(x, y, rX, rY, rot, start, end, color) {\n    var _this;\n    var borderColor = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n    var borderWidth = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;\n    _classCallCheck(this, Ellipse);\n    _this = _callSuper(this, Ellipse, [x, y, rX * 2, rY * 2, color]); // Для эллипса используем радиусы по осям X и Y как размер\n    _this.rX = rX;\n    _this.rY = rY;\n    _this.rot = rot;\n    _this.start = start;\n    _this.end = end;\n    _this.borderColor = borderColor;\n    _this.borderWidth = borderWidth;\n    return _this;\n  }\n\n  // Метод для рендеринга эллипса\n  _inherits(Ellipse, _GameObject);\n  return _createClass(Ellipse, [{\n    key: \"render\",\n    value: function render(context) {\n      context.beginPath();\n\n      // Рисуем эллипс\n      context.ellipse(this.x, this.y, this.rX, this.rY, this.rot, this.start, this.end * Math.PI);\n\n      // Основной цвет заливки\n      context.fillStyle = this.color;\n      context.fill();\n\n      // Если есть граница, рисуем её\n      if (this.borderColor) {\n        context.strokeStyle = this.borderColor;\n        context.lineWidth = this.borderWidth;\n        context.stroke();\n      }\n      context.closePath();\n    }\n  }]);\n}(_gameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject);\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/gameObjects/shapes/2d/Ellipse.js?");

/***/ }),

/***/ "./TETTE_CORE/gameObjects/shapes/2d/Line.js":
/*!**************************************************!*\
  !*** ./TETTE_CORE/gameObjects/shapes/2d/Line.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Line: () => (/* binding */ Line)\n/* harmony export */ });\n/* harmony import */ var _gameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gameObject.js */ \"./TETTE_CORE/gameObjects/shapes/gameObject.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\nvar Line = /*#__PURE__*/function (_GameObject) {\n  function Line(x1, y1, x2, y2) {\n    var _this;\n    var color = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'black';\n    var widthline = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n    var lineRounded = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'butt';\n    _classCallCheck(this, Line);\n    _this = _callSuper(this, Line, [x1, y1, x2 - x1, y2 - y1, color]); // x2 и y2 используем для вычисления длины линии\n    _this.x1 = x1;\n    _this.y1 = y1;\n    _this.x2 = x2;\n    _this.y2 = y2;\n    _this.color = color;\n    _this.widthline = widthline;\n    _this.lineRounded = lineRounded; // Возможные значения: 'butt', 'round', 'square'\n    return _this;\n  }\n\n  // Метод для рендеринга линии\n  _inherits(Line, _GameObject);\n  return _createClass(Line, [{\n    key: \"render\",\n    value: function render(context) {\n      context.beginPath();\n\n      // Начальная точка\n      context.moveTo(this.x1, this.y1);\n\n      // Конечная точка\n      context.lineTo(this.x2, this.y2);\n\n      // Цвет и ширина линии\n      context.strokeStyle = this.color;\n      context.lineWidth = this.widthline;\n\n      // Установка формы концов линии\n      context.lineCap = this.lineRounded;\n\n      // Рисуем линию\n      context.stroke();\n      context.closePath();\n    }\n  }]);\n}(_gameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject);\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/gameObjects/shapes/2d/Line.js?");

/***/ }),

/***/ "./TETTE_CORE/gameObjects/shapes/2d/Polygon.js":
/*!*****************************************************!*\
  !*** ./TETTE_CORE/gameObjects/shapes/2d/Polygon.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Polygon: () => (/* binding */ Polygon)\n/* harmony export */ });\n/* harmony import */ var _gameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gameObject.js */ \"./TETTE_CORE/gameObjects/shapes/gameObject.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\nvar Polygon = /*#__PURE__*/function (_GameObject) {\n  function Polygon(vertices) {\n    var _this;\n    var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'black';\n    var borderColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var borderWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    _classCallCheck(this, Polygon);\n    _this = _callSuper(this, Polygon, [vertices[0].x, vertices[0].y, 0, 0, color]); // Используем первую вершину для инициализации\n    _this.vertices = vertices;\n    _this.color = color;\n    _this.borderColor = borderColor;\n    _this.borderWidth = borderWidth;\n    return _this;\n  }\n  _inherits(Polygon, _GameObject);\n  return _createClass(Polygon, [{\n    key: \"render\",\n    value: function render(context) {\n      context.beginPath();\n      context.moveTo(this.vertices[0].x, this.vertices[0].y);\n      for (var i = 1; i < this.vertices.length; i++) {\n        context.lineTo(this.vertices[i].x, this.vertices[i].y);\n      }\n      context.closePath();\n      context.fillStyle = this.color;\n      context.fill();\n      if (this.borderColor) {\n        context.strokeStyle = this.borderColor;\n        context.lineWidth = this.borderWidth;\n        context.stroke();\n      }\n    }\n  }]);\n}(_gameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject);\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/gameObjects/shapes/2d/Polygon.js?");

/***/ }),

/***/ "./TETTE_CORE/gameObjects/shapes/2d/Rectangle.js":
/*!*******************************************************!*\
  !*** ./TETTE_CORE/gameObjects/shapes/2d/Rectangle.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Rectangle: () => (/* binding */ Rectangle)\n/* harmony export */ });\n/* harmony import */ var _gameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gameObject.js */ \"./TETTE_CORE/gameObjects/shapes/gameObject.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\nvar Rectangle = /*#__PURE__*/function (_GameObject) {\n  function Rectangle(x, y, width) {\n    var _this;\n    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : width;\n    var color = arguments.length > 4 ? arguments[4] : undefined;\n    var borderColor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    var borderWidth = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n    var round = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n    _classCallCheck(this, Rectangle);\n    _this = _callSuper(this, Rectangle, [x, y, width, height, color]); // Теперь ширина и высота могут быть разными\n    _this.borderColor = borderColor;\n    _this.borderWidth = borderWidth;\n    _this.round = round;\n    return _this;\n  }\n\n  // Метод для рендеринга квадрата/прямоугольника\n  _inherits(Rectangle, _GameObject);\n  return _createClass(Rectangle, [{\n    key: \"render\",\n    value: function render(context) {\n      context.beginPath();\n\n      // Если нужно закруглить углы\n      if (this.round > 0) {\n        this.roundedRect(context, this.x, this.y, this.width, this.height, this.round);\n      } else {\n        context.rect(this.x, this.y, this.width, this.height);\n      }\n\n      // Основной цвет заливки\n      context.fillStyle = this.color;\n      context.fill();\n\n      // Если есть граница, рисуем её\n      if (this.borderColor) {\n        context.strokeStyle = this.borderColor;\n        context.lineWidth = this.borderWidth;\n        context.stroke();\n      }\n      context.closePath();\n    }\n\n    // Метод для рисования закругленного прямоугольника\n  }, {\n    key: \"roundedRect\",\n    value: function roundedRect(context, x, y, width, height, radius) {\n      context.moveTo(x + radius, y);\n      context.arcTo(x + width, y, x + width, y + height, radius);\n      context.arcTo(x + width, y + height, x, y + height, radius);\n      context.arcTo(x, y + height, x, y, radius);\n      context.arcTo(x, y, x + width, y, radius);\n    }\n  }]);\n}(_gameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject);\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/gameObjects/shapes/2d/Rectangle.js?");

/***/ }),

/***/ "./TETTE_CORE/gameObjects/shapes/2d/Sprite.js":
/*!****************************************************!*\
  !*** ./TETTE_CORE/gameObjects/shapes/2d/Sprite.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Sprite: () => (/* binding */ Sprite)\n/* harmony export */ });\n/* harmony import */ var _gameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gameObject.js */ \"./TETTE_CORE/gameObjects/shapes/gameObject.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\nvar Sprite = /*#__PURE__*/function (_GameObject) {\n  function Sprite(params) {\n    var _this;\n    _classCallCheck(this, Sprite);\n    _this = _callSuper(this, Sprite, [{\n      x: params.x,\n      y: params.y,\n      width: params.width,\n      height: params.height,\n      color: null,\n      // Цвет можно задать null, так как это спрайт\n      enablePhysics: params.enablePhysics || false,\n      isStatic: params.isStatic || false,\n      layer: params.layer || 0 // Добавляем слой рендеринга\n    }]);\n    _this.image = params.image;\n    _this.preserveAspectRatio = params.preserveAspectRatio || false;\n    return _this;\n  }\n  _inherits(Sprite, _GameObject);\n  return _createClass(Sprite, [{\n    key: \"update\",\n    value: function update(deltaTime) {\n      if (this.rigidBody) {\n        this.x = this.rigidBody.x;\n        this.y = this.rigidBody.y;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(context) {\n      if (this.image.complete) {\n        var renderWidth = this.width;\n        var renderHeight = this.height;\n        if (this.preserveAspectRatio) {\n          var aspectRatio = this.image.width / this.image.height;\n          if (this.width / this.height > aspectRatio) {\n            renderWidth = this.height * aspectRatio;\n          } else {\n            renderHeight = this.width / aspectRatio;\n          }\n        }\n        context.drawImage(this.image, this.x, this.y, renderWidth, renderHeight);\n      }\n    }\n  }]);\n}(_gameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject);\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/gameObjects/shapes/2d/Sprite.js?");

/***/ }),

/***/ "./TETTE_CORE/gameObjects/shapes/2d/Star.js":
/*!**************************************************!*\
  !*** ./TETTE_CORE/gameObjects/shapes/2d/Star.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Star: () => (/* binding */ Star)\n/* harmony export */ });\n/* harmony import */ var _gameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gameObject.js */ \"./TETTE_CORE/gameObjects/shapes/gameObject.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\nvar Star = /*#__PURE__*/function (_GameObject) {\n  function Star(x, y, radius, points) {\n    var _this;\n    var color = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'black';\n    var borderColor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    var borderWidth = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n    _classCallCheck(this, Star);\n    _this = _callSuper(this, Star, [x, y, radius * 2, radius * 2, color]);\n    _this.radius = radius;\n    _this.points = points;\n    _this.color = color;\n    _this.borderColor = borderColor;\n    _this.borderWidth = borderWidth;\n    return _this;\n  }\n  _inherits(Star, _GameObject);\n  return _createClass(Star, [{\n    key: \"render\",\n    value: function render(context) {\n      var step = Math.PI / this.points;\n      context.beginPath();\n      context.moveTo(this.x + this.radius * Math.cos(0), this.y - this.radius * Math.sin(0));\n      for (var i = 0; i <= 2 * this.points; i++) {\n        var angle = i * step;\n        var radius = i % 2 === 0 ? this.radius : this.radius / 2;\n        context.lineTo(this.x + radius * Math.cos(angle), this.y - radius * Math.sin(angle));\n      }\n      context.closePath();\n      context.fillStyle = this.color;\n      context.fill();\n      if (this.borderColor) {\n        context.strokeStyle = this.borderColor;\n        context.lineWidth = this.borderWidth;\n        context.stroke();\n      }\n    }\n  }]);\n}(_gameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject);\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/gameObjects/shapes/2d/Star.js?");

/***/ }),

/***/ "./TETTE_CORE/gameObjects/shapes/2d/Text.js":
/*!**************************************************!*\
  !*** ./TETTE_CORE/gameObjects/shapes/2d/Text.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Text: () => (/* binding */ Text)\n/* harmony export */ });\n/* harmony import */ var _gameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gameObject.js */ \"./TETTE_CORE/gameObjects/shapes/gameObject.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\nvar Text = /*#__PURE__*/function (_GameObject) {\n  function Text(text, x, y) {\n    var _this;\n    var fontsize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 16;\n    var color = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'black';\n    var fontFamily = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'Arial';\n    var borderColor = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n    var borderWidth = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n    _classCallCheck(this, Text);\n    // Передаем координаты и цвет в конструктор базового класса\n    _this = _callSuper(this, Text, [x, y, 0, 0, color]);\n    _this.text = text;\n    _this.fontsize = fontsize;\n    _this.fontFamily = fontFamily;\n    _this.borderColor = borderColor;\n    _this.borderWidth = borderWidth;\n    return _this;\n  }\n\n  // Метод для рендеринга текста\n  _inherits(Text, _GameObject);\n  return _createClass(Text, [{\n    key: \"render\",\n    value: function render(context) {\n      context.beginPath();\n\n      // Устанавливаем шрифт и цвет текста\n      context.font = \"\".concat(this.fontsize, \"px \").concat(this.fontFamily);\n      context.fillStyle = this.color;\n\n      // Отрисовываем текст\n      context.fillText(this.text, this.x, this.y);\n\n      // Если есть граница, рисуем её\n      if (this.borderColor && this.borderWidth > 0) {\n        context.strokeStyle = this.borderColor;\n        context.lineWidth = this.borderWidth;\n        context.strokeText(this.text, this.x, this.y);\n      }\n      context.closePath();\n    }\n  }]);\n}(_gameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject);\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/gameObjects/shapes/2d/Text.js?");

/***/ }),

/***/ "./TETTE_CORE/gameObjects/shapes/2d/shape.js":
/*!***************************************************!*\
  !*** ./TETTE_CORE/gameObjects/shapes/2d/shape.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getShapes: () => (/* binding */ getShapes)\n/* harmony export */ });\n/* harmony import */ var _Rectangle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Rectangle.js */ \"./TETTE_CORE/gameObjects/shapes/2d/Rectangle.js\");\n/* harmony import */ var _Circle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Circle.js */ \"./TETTE_CORE/gameObjects/shapes/2d/Circle.js\");\n/* harmony import */ var _Ellipse_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Ellipse.js */ \"./TETTE_CORE/gameObjects/shapes/2d/Ellipse.js\");\n/* harmony import */ var _Text_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Text.js */ \"./TETTE_CORE/gameObjects/shapes/2d/Text.js\");\n/* harmony import */ var _Sprite_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Sprite.js */ \"./TETTE_CORE/gameObjects/shapes/2d/Sprite.js\");\n/* harmony import */ var _Line_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Line.js */ \"./TETTE_CORE/gameObjects/shapes/2d/Line.js\");\n/* harmony import */ var _Polygon_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Polygon.js */ \"./TETTE_CORE/gameObjects/shapes/2d/Polygon.js\");\n/* harmony import */ var _BezierCurve_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./BezierCurve.js */ \"./TETTE_CORE/gameObjects/shapes/2d/BezierCurve.js\");\n/* harmony import */ var _Star_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Star.js */ \"./TETTE_CORE/gameObjects/shapes/2d/Star.js\");\n/* harmony import */ var _core_core_logic_ColorMixin_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../core/core_logic/ColorMixin.js */ \"./TETTE_CORE/core/core_logic/ColorMixin.js\");\n/* harmony import */ var _utils_SpriteGrid_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../utils/SpriteGrid.js */ \"./TETTE_CORE/gameObjects/utils/SpriteGrid.js\");\n\n\n\n\n // Обновлённый класс Sprite\n\n\n\n\n // Убедитесь в правильности пути\n // Импортируем компонент сетки спрайтов\nfunction getShapes(renderType) {\n  return {\n    // Функция для создания квадрата\n    square: function square(params) {\n      var color = (0,_core_core_logic_ColorMixin_js__WEBPACK_IMPORTED_MODULE_9__.ColorMixin)(params.color, renderType);\n      var borderColor = params.borderColor ? (0,_core_core_logic_ColorMixin_js__WEBPACK_IMPORTED_MODULE_9__.ColorMixin)(params.borderColor, renderType) : null;\n      return new _Rectangle_js__WEBPACK_IMPORTED_MODULE_0__.Rectangle({\n        x: params.x,\n        y: params.y,\n        width: params.size,\n        height: params.size,\n        color: color,\n        borderColor: borderColor,\n        borderWidth: params.borderWidth,\n        round: params.round,\n        enablePhysics: params.enablePhysics || false,\n        // Поддержка физики\n        isStatic: params.isStatic || false,\n        layer: params.layer || 0 // Добавлен параметр layer\n      });\n    },\n    // Функция для создания прямоугольника\n    rectangle: function rectangle(params) {\n      var color = (0,_core_core_logic_ColorMixin_js__WEBPACK_IMPORTED_MODULE_9__.ColorMixin)(params.color, renderType);\n      var borderColor = params.borderColor ? (0,_core_core_logic_ColorMixin_js__WEBPACK_IMPORTED_MODULE_9__.ColorMixin)(params.borderColor, renderType) : null;\n      return new _Rectangle_js__WEBPACK_IMPORTED_MODULE_0__.Rectangle({\n        x: params.x,\n        y: params.y,\n        width: params.width,\n        height: params.height,\n        color: color,\n        borderColor: borderColor,\n        borderWidth: params.borderWidth,\n        enablePhysics: params.enablePhysics || false,\n        // Поддержка физики\n        isStatic: params.isStatic || false,\n        layer: params.layer || 0 // Добавлен параметр layer\n      });\n    },\n    // Функция для создания круга\n    circle: function circle(params) {\n      var color = (0,_core_core_logic_ColorMixin_js__WEBPACK_IMPORTED_MODULE_9__.ColorMixin)(params.color, renderType);\n      var borderColor = params.borderColor ? (0,_core_core_logic_ColorMixin_js__WEBPACK_IMPORTED_MODULE_9__.ColorMixin)(params.borderColor, renderType) : null;\n      return new _Circle_js__WEBPACK_IMPORTED_MODULE_1__.Circle({\n        x: params.x,\n        y: params.y,\n        radius: params.radius,\n        color: color,\n        borderColor: borderColor,\n        borderWidth: params.borderWidth,\n        enablePhysics: params.enablePhysics || false,\n        // Поддержка физики\n        isStatic: params.isStatic || false,\n        layer: params.layer || 0 // Добавлен параметр layer\n      });\n    },\n    // Функция для создания дуги\n    arc: function arc(params) {\n      var color = (0,_core_core_logic_ColorMixin_js__WEBPACK_IMPORTED_MODULE_9__.ColorMixin)(params.color, renderType);\n      var borderColor = params.borderColor ? (0,_core_core_logic_ColorMixin_js__WEBPACK_IMPORTED_MODULE_9__.ColorMixin)(params.borderColor, renderType) : null;\n      return new _Circle_js__WEBPACK_IMPORTED_MODULE_1__.Circle({\n        x: params.x,\n        y: params.y,\n        radius: params.radius,\n        startAngle: params.startAngle,\n        endAngle: params.endAngle,\n        color: color,\n        borderColor: borderColor,\n        borderWidth: params.borderWidth,\n        enablePhysics: params.enablePhysics || false,\n        // Поддержка физики\n        isStatic: params.isStatic || false,\n        layer: params.layer || 0 // Добавлен параметр layer\n      });\n    },\n    // Функция для создания эллипса\n    ellipse: function ellipse(params) {\n      var color = (0,_core_core_logic_ColorMixin_js__WEBPACK_IMPORTED_MODULE_9__.ColorMixin)(params.color, renderType);\n      var borderColor = params.borderColor ? (0,_core_core_logic_ColorMixin_js__WEBPACK_IMPORTED_MODULE_9__.ColorMixin)(params.borderColor, renderType) : null;\n      return new _Ellipse_js__WEBPACK_IMPORTED_MODULE_2__.Ellipse({\n        x: params.x,\n        y: params.y,\n        radiusX: params.rX,\n        radiusY: params.rY,\n        rotation: params.rot || 0,\n        startAngle: params.start || 0,\n        endAngle: params.end || 2 * Math.PI,\n        color: color,\n        borderColor: borderColor,\n        borderWidth: params.borderWidth,\n        enablePhysics: params.enablePhysics || false,\n        // Поддержка физики\n        isStatic: params.isStatic || false,\n        layer: params.layer || 0 // Добавлен параметр layer\n      });\n    },\n    // Функция для создания текста\n    text: function text(params) {\n      var color = (0,_core_core_logic_ColorMixin_js__WEBPACK_IMPORTED_MODULE_9__.ColorMixin)(params.color || 'black', renderType);\n      var borderColor = params.borderColor ? (0,_core_core_logic_ColorMixin_js__WEBPACK_IMPORTED_MODULE_9__.ColorMixin)(params.borderColor, renderType) : null;\n      return new _Text_js__WEBPACK_IMPORTED_MODULE_3__.Text({\n        text: params.text,\n        x: params.x,\n        y: params.y,\n        fontSize: params.fontsize || 16,\n        fontFamily: params.fontFamily || 'Arial',\n        color: color,\n        borderColor: borderColor,\n        borderWidth: params.borderWidth,\n        enablePhysics: params.enablePhysics || false,\n        // Поддержка физики\n        isStatic: params.isStatic || false,\n        layer: params.layer || 0 // Добавлен параметр layer\n      });\n    },\n    // Функция для создания спрайта\n    sprite: function sprite(params) {\n      return new _Sprite_js__WEBPACK_IMPORTED_MODULE_4__.Sprite({\n        image: params.image,\n        x: params.x,\n        y: params.y,\n        width: params.width,\n        height: params.height,\n        preserveAspectRatio: params.preserveAspectRatio || false,\n        enablePhysics: params.enablePhysics || false,\n        // Поддержка физики\n        isStatic: params.isStatic || false,\n        layer: params.layer || 0 // Добавлен параметр layer\n      });\n    },\n    // Функция для создания сетки спрайтов\n    spriteGrid: function spriteGrid(params) {\n      return new _utils_SpriteGrid_js__WEBPACK_IMPORTED_MODULE_10__.SpriteGrid({\n        image: params.image,\n        x: params.x,\n        y: params.y,\n        width: params.width,\n        height: params.height,\n        repeatX: params.repeatX || 1,\n        repeatY: params.repeatY || 1,\n        spacingX: params.spacingX || 0,\n        spacingY: params.spacingY || 0,\n        preserveAspectRatio: params.preserveAspectRatio || false,\n        enablePhysics: params.enablePhysics || false,\n        // Поддержка физики\n        isStatic: params.isStatic || false,\n        layer: params.layer || 0 // Добавлен параметр layer\n      });\n    },\n    // Функция для создания линии\n    line: function line(params) {\n      var color = (0,_core_core_logic_ColorMixin_js__WEBPACK_IMPORTED_MODULE_9__.ColorMixin)(params.color || 'black', renderType);\n      return new _Line_js__WEBPACK_IMPORTED_MODULE_5__.Line({\n        x1: params.x1,\n        y1: params.y1,\n        x2: params.x2,\n        y2: params.y2,\n        color: color,\n        lineWidth: params.widthline || 1,\n        lineCap: params.lineRounded || 'butt',\n        enablePhysics: params.enablePhysics || false,\n        // Поддержка физики\n        isStatic: params.isStatic || false,\n        layer: params.layer || 0 // Добавлен параметр layer\n      });\n    },\n    // Функция для создания многоугольника\n    polygon: function polygon(params) {\n      var color = (0,_core_core_logic_ColorMixin_js__WEBPACK_IMPORTED_MODULE_9__.ColorMixin)(params.color, renderType);\n      var borderColor = params.borderColor ? (0,_core_core_logic_ColorMixin_js__WEBPACK_IMPORTED_MODULE_9__.ColorMixin)(params.borderColor, renderType) : null;\n      return new _Polygon_js__WEBPACK_IMPORTED_MODULE_6__.Polygon({\n        vertices: params.vertices,\n        color: color,\n        borderColor: borderColor,\n        borderWidth: params.borderWidth,\n        enablePhysics: params.enablePhysics || false,\n        // Поддержка физики\n        isStatic: params.isStatic || false,\n        layer: params.layer || 0 // Добавлен параметр layer\n      });\n    },\n    // Функция для создания кривой Безье\n    bezierCurve: function bezierCurve(params) {\n      var color = (0,_core_core_logic_ColorMixin_js__WEBPACK_IMPORTED_MODULE_9__.ColorMixin)(params.color, renderType);\n      return new _BezierCurve_js__WEBPACK_IMPORTED_MODULE_7__.BezierCurve({\n        startX: params.startX,\n        startY: params.startY,\n        controlX1: params.controlX1,\n        controlY1: params.controlY1,\n        controlX2: params.controlX2,\n        controlY2: params.controlY2,\n        endX: params.endX,\n        endY: params.endY,\n        color: color,\n        lineWidth: params.widthline || 1,\n        enablePhysics: params.enablePhysics || false,\n        // Поддержка физики\n        isStatic: params.isStatic || false,\n        layer: params.layer || 0 // Добавлен параметр layer\n      });\n    },\n    // Функция для создания звезды\n    star: function star(params) {\n      var color = (0,_core_core_logic_ColorMixin_js__WEBPACK_IMPORTED_MODULE_9__.ColorMixin)(params.color, renderType);\n      var borderColor = params.borderColor ? (0,_core_core_logic_ColorMixin_js__WEBPACK_IMPORTED_MODULE_9__.ColorMixin)(params.borderColor, renderType) : null;\n      return new _Star_js__WEBPACK_IMPORTED_MODULE_8__.Star({\n        x: params.x,\n        y: params.y,\n        radius: params.radius,\n        points: params.points,\n        color: color,\n        borderColor: borderColor,\n        borderWidth: params.borderWidth,\n        enablePhysics: params.enablePhysics || false,\n        // Поддержка физики\n        isStatic: params.isStatic || false,\n        layer: params.layer || 0 // Добавлен параметр layer\n      });\n    },\n    // Функция для создания точки\n    point: function point(params) {\n      var color = (0,_core_core_logic_ColorMixin_js__WEBPACK_IMPORTED_MODULE_9__.ColorMixin)(params.color || 'black', renderType);\n      return new _Circle_js__WEBPACK_IMPORTED_MODULE_1__.Circle({\n        x: params.x,\n        y: params.y,\n        radius: params.size || 5,\n        color: color,\n        enablePhysics: params.enablePhysics || false,\n        // Поддержка физики\n        isStatic: params.isStatic || false,\n        layer: params.layer || 0 // Добавлен параметр layer\n      });\n    }\n  };\n}\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/gameObjects/shapes/2d/shape.js?");

/***/ }),

/***/ "./TETTE_CORE/gameObjects/shapes/gameObject.js":
/*!*****************************************************!*\
  !*** ./TETTE_CORE/gameObjects/shapes/gameObject.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameObject: () => (/* binding */ GameObject)\n/* harmony export */ });\n/* harmony import */ var _core_physics_RigidBody2d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/physics/RigidBody2d.js */ \"./TETTE_CORE/core/physics/RigidBody2d.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar GameObject = /*#__PURE__*/function () {\n  function GameObject(_ref) {\n    var x = _ref.x,\n      y = _ref.y,\n      width = _ref.width,\n      height = _ref.height,\n      color = _ref.color,\n      _ref$enablePhysics = _ref.enablePhysics,\n      enablePhysics = _ref$enablePhysics === void 0 ? false : _ref$enablePhysics,\n      _ref$isStatic = _ref.isStatic,\n      isStatic = _ref$isStatic === void 0 ? false : _ref$isStatic,\n      _ref$layer = _ref.layer,\n      layer = _ref$layer === void 0 ? 0 : _ref$layer;\n    _classCallCheck(this, GameObject);\n    this.x = x; // Позиция по X\n    this.y = y; // Позиция по Y\n    this.width = width; // Ширина объекта\n    this.height = height; // Высота объекта\n    this.color = color; // Цвет объекта\n    this.layer = layer; // Слой для рендеринга (чем меньше значение, тем раньше рендерится)\n\n    // Добавляем поддержку физики\n    if (enablePhysics) {\n      this.rigidBody = new _core_physics_RigidBody2d_js__WEBPACK_IMPORTED_MODULE_0__.RigidBody2d({\n        isStatic: isStatic\n      });\n      this.rigidBody.x = this.x;\n      this.rigidBody.y = this.y;\n      this.rigidBody.width = this.width;\n      this.rigidBody.height = this.height;\n    } else {\n      this.rigidBody = null;\n    }\n  }\n\n  // Метод для обновления позиции объекта\n  return _createClass(GameObject, [{\n    key: \"update\",\n    value: function update(deltaTime) {\n      if (this.rigidBody) {\n        // Если физика включена, обновляем позиции из rigidBody\n        this.x = this.rigidBody.x;\n        this.y = this.rigidBody.y;\n      } else {\n        // Обновляем позицию на основе скорости и времени\n        this.x += this.speedX * deltaTime / 1000; // Скорость в пикселях/секунду\n        this.y += this.speedY * deltaTime / 1000;\n      }\n    }\n\n    // Метод для рендеринга объекта (будет переопределяться в дочерних классах)\n  }, {\n    key: \"render\",\n    value: function render(context) {\n      // Этот метод будет реализован в конкретных примитивах (например, квадрат, круг)\n      // context — это контекст 2D/WebGL, передаваемый для рендеринга\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/gameObjects/shapes/gameObject.js?");

/***/ }),

/***/ "./TETTE_CORE/gameObjects/utils/SpriteGrid.js":
/*!****************************************************!*\
  !*** ./TETTE_CORE/gameObjects/utils/SpriteGrid.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SpriteGrid: () => (/* binding */ SpriteGrid)\n/* harmony export */ });\n/* harmony import */ var _shapes_gameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shapes/gameObject.js */ \"./TETTE_CORE/gameObjects/shapes/gameObject.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\nvar SpriteGrid = /*#__PURE__*/function (_GameObject) {\n  function SpriteGrid(_ref) {\n    var _this;\n    var image = _ref.image,\n      x = _ref.x,\n      y = _ref.y,\n      width = _ref.width,\n      height = _ref.height,\n      _ref$repeatX = _ref.repeatX,\n      repeatX = _ref$repeatX === void 0 ? 1 : _ref$repeatX,\n      _ref$repeatY = _ref.repeatY,\n      repeatY = _ref$repeatY === void 0 ? 1 : _ref$repeatY,\n      _ref$spacingX = _ref.spacingX,\n      spacingX = _ref$spacingX === void 0 ? 0 : _ref$spacingX,\n      _ref$spacingY = _ref.spacingY,\n      spacingY = _ref$spacingY === void 0 ? 0 : _ref$spacingY,\n      _ref$preserveAspectRa = _ref.preserveAspectRatio,\n      preserveAspectRatio = _ref$preserveAspectRa === void 0 ? false : _ref$preserveAspectRa,\n      _ref$enablePhysics = _ref.enablePhysics,\n      enablePhysics = _ref$enablePhysics === void 0 ? false : _ref$enablePhysics,\n      _ref$isStatic = _ref.isStatic,\n      isStatic = _ref$isStatic === void 0 ? false : _ref$isStatic,\n      _ref$layer = _ref.layer,\n      layer = _ref$layer === void 0 ? 0 : _ref$layer;\n    _classCallCheck(this, SpriteGrid);\n    _this = _callSuper(this, SpriteGrid, [{\n      x: x,\n      y: y,\n      width: width * repeatX + spacingX * (repeatX - 1),\n      // Общая ширина сетки\n      height: height * repeatY + spacingY * (repeatY - 1),\n      // Общая высота сетки\n      color: null,\n      enablePhysics: enablePhysics,\n      isStatic: isStatic,\n      layer: layer // Устанавливаем слой в родительском классе\n    }]);\n    _this.image = image;\n    _this.repeatX = repeatX;\n    _this.repeatY = repeatY;\n    _this.spacingX = spacingX;\n    _this.spacingY = spacingY;\n    _this.preserveAspectRatio = preserveAspectRatio;\n    return _this;\n  }\n  _inherits(SpriteGrid, _GameObject);\n  return _createClass(SpriteGrid, [{\n    key: \"update\",\n    value: function update(deltaTime) {\n      // Если физика включена, обновляем позиции из rigidBody\n      if (this.rigidBody) {\n        this.x = this.rigidBody.x;\n        this.y = this.rigidBody.y;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(context) {\n      if (this.image.complete) {\n        var renderWidth = this.width / this.repeatX;\n        var renderHeight = this.height / this.repeatY;\n        for (var i = 0; i < this.repeatX; i++) {\n          for (var j = 0; j < this.repeatY; j++) {\n            context.drawImage(this.image, this.x + (renderWidth + this.spacingX) * i, this.y + (renderHeight + this.spacingY) * j, renderWidth, renderHeight);\n          }\n        }\n      }\n    }\n  }]);\n}(_shapes_gameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject);\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/gameObjects/utils/SpriteGrid.js?");

/***/ }),

/***/ "./TETTE_CORE/gameTypePresets/GameType.js":
/*!************************************************!*\
  !*** ./TETTE_CORE/gameTypePresets/GameType.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameType: () => (/* binding */ GameType)\n/* harmony export */ });\n/* harmony import */ var _core_physics_PhysicsEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/physics/PhysicsEngine.js */ \"./TETTE_CORE/core/physics/PhysicsEngine.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// GameType.js\n\nvar GameType = /*#__PURE__*/function () {\n  function GameType(core) {\n    _classCallCheck(this, GameType);\n    this.core = core;\n    this.sceneManager = core.sceneManager;\n    this.physicsEngine = new _core_physics_PhysicsEngine_js__WEBPACK_IMPORTED_MODULE_0__.PhysicsEngine();\n  }\n  return _createClass(GameType, [{\n    key: \"start\",\n    value: function start() {\n      // Метод, вызываемый при старте игры\n    }\n  }, {\n    key: \"update\",\n    value: function update(deltaTime) {\n      var currentScene = this.sceneManager.getCurrentScene();\n      if (!currentScene) return;\n\n      // Обновляем физику\n      this.physicsEngine.updatePhysics(currentScene.gameObjects, deltaTime);\n\n      // Обработка специфичной логики для типа игры\n      this.handleGameTypeSpecificLogic(deltaTime);\n    }\n  }, {\n    key: \"handleGameTypeSpecificLogic\",\n    value: function handleGameTypeSpecificLogic(deltaTime) {\n      // Этот метод должен быть переопределен в подклассах\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/gameTypePresets/GameType.js?");

/***/ }),

/***/ "./TETTE_CORE/gameTypePresets/PlatformerGameType.js":
/*!**********************************************************!*\
  !*** ./TETTE_CORE/gameTypePresets/PlatformerGameType.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlatformerGameType: () => (/* binding */ PlatformerGameType)\n/* harmony export */ });\n/* harmony import */ var _GameType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GameType.js */ \"./TETTE_CORE/gameTypePresets/GameType.js\");\n/* harmony import */ var _gameObjects_characters_PlatformerPlayerCharacter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gameObjects/characters/PlatformerPlayerCharacter.js */ \"./TETTE_CORE/gameObjects/characters/PlatformerPlayerCharacter.js\");\n/* harmony import */ var _core_controls_keyboardControl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/controls/keyboardControl.js */ \"./TETTE_CORE/core/controls/keyboardControl.js\");\n/* harmony import */ var _gameObjects_characters_Enemy_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../gameObjects/characters/Enemy.js */ \"./TETTE_CORE/gameObjects/characters/Enemy.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n// PlatformerGameType.js\n\n\n\n\nvar PlatformerGameType = /*#__PURE__*/function (_GameType) {\n  function PlatformerGameType(core) {\n    var _this;\n    _classCallCheck(this, PlatformerGameType);\n    _this = _callSuper(this, PlatformerGameType, [core]);\n    _this.player = _this.getPlayerFromCurrentScene();\n    _this.keyboardControl = new _core_controls_keyboardControl_js__WEBPACK_IMPORTED_MODULE_2__.KeyboardControl();\n    return _this;\n  }\n  _inherits(PlatformerGameType, _GameType);\n  return _createClass(PlatformerGameType, [{\n    key: \"getPlayerFromCurrentScene\",\n    value: function getPlayerFromCurrentScene() {\n      var currentScene = this.sceneManager.getCurrentScene();\n      if (!currentScene) {\n        console.error(\"No current scene found.\");\n        return null;\n      }\n      return currentScene.gameObjects.find(function (obj) {\n        return obj instanceof _gameObjects_characters_PlatformerPlayerCharacter_js__WEBPACK_IMPORTED_MODULE_1__.PlatformerPlayerCharacter;\n      });\n    }\n  }, {\n    key: \"handleGameTypeSpecificLogic\",\n    value: function handleGameTypeSpecificLogic(deltaTime) {\n      // Обработка ввода для игрока\n      if (this.player && this.player.rigidBody) {\n        this.handleInput(deltaTime);\n      }\n    }\n  }, {\n    key: \"handleInput\",\n    value: function handleInput(deltaTime) {\n      var rigidBody = this.player.rigidBody;\n      var SPEED_SCALE = 6000;\n      var deltaSeconds = deltaTime / 1000;\n      var moveSpeed = this.player.speed * SPEED_SCALE * deltaSeconds;\n      if (this.keyboardControl.isKeyPressed('ArrowLeft')) {\n        rigidBody.velocityX = -moveSpeed;\n      } else if (this.keyboardControl.isKeyPressed('ArrowRight')) {\n        rigidBody.velocityX = moveSpeed;\n      } else {\n        rigidBody.velocityX = 0;\n      }\n      if (this.keyboardControl.isKeyPressed(' ') && rigidBody.onGround) {\n        rigidBody.velocityY = -1200; // Скорость прыжка\n        rigidBody.onGround = false;\n      }\n    }\n  }, {\n    key: \"checkPlayerEnemyCollisions\",\n    value: function checkPlayerEnemyCollisions() {\n      var _this2 = this;\n      var currentScene = this.sceneManager.getCurrentScene();\n      var enemies = currentScene.gameObjects.filter(function (obj) {\n        return obj instanceof _gameObjects_characters_Enemy_js__WEBPACK_IMPORTED_MODULE_3__.Enemy;\n      });\n      enemies.forEach(function (enemy) {\n        if (_this2.isColliding(_this2.player, enemy)) {\n          _this2.resolvePlayerEnemyCollision(_this2.player, enemy);\n        }\n      });\n    }\n  }, {\n    key: \"resolvePlayerEnemyCollision\",\n    value: function resolvePlayerEnemyCollision(player, enemy) {\n      var _this3 = this;\n      // Проверяем, прыгает ли игрок на врага\n      if (player.rigidBody.velocityY > 0 && player.y + player.height <= enemy.y + enemy.height / 2) {\n        // Враг побежден\n        enemy.setAnimation('die');\n\n        // Удаляем врага после окончания анимации\n        setTimeout(function () {\n          var currentScene = _this3.sceneManager.getCurrentScene();\n          _this3.sceneManager.removeGameObjectFromScene(currentScene.name, enemy);\n        }, enemy.frameDuration * enemy.animations.die.length);\n\n        // Увеличиваем счет игрока\n        this.score += 100;\n\n        // Отталкиваем игрока вверх\n        player.rigidBody.velocityY = -600;\n      } else {\n        // Игрок получает урон\n        player.health -= 1;\n        if (player.health <= 0) {\n          // Обрабатываем смерть игрока\n          console.log(\"Игрок погиб!\");\n          // Здесь можно перезапустить игру или уровень\n        }\n      }\n    }\n  }]);\n}(_GameType_js__WEBPACK_IMPORTED_MODULE_0__.GameType);\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/gameTypePresets/PlatformerGameType.js?");

/***/ }),

/***/ "./TETTE_CORE/index.js":
/*!*****************************!*\
  !*** ./TETTE_CORE/index.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Circle: () => (/* reexport safe */ _gameObjects_shapes_2d_Circle_js__WEBPACK_IMPORTED_MODULE_5__.Circle),\n/* harmony export */   Core: () => (/* reexport safe */ _core_core_logic_Core_js__WEBPACK_IMPORTED_MODULE_0__.Core),\n/* harmony export */   GraphicalContext: () => (/* reexport safe */ _core_core_logic_GraphicalContext_js__WEBPACK_IMPORTED_MODULE_3__.GraphicalContext),\n/* harmony export */   KeyboardControl: () => (/* reexport safe */ _core_controls_keyboardControl_js__WEBPACK_IMPORTED_MODULE_7__.KeyboardControl),\n/* harmony export */   MouseControl: () => (/* reexport safe */ _core_controls_mouseControl_js__WEBPACK_IMPORTED_MODULE_8__.MouseControl),\n/* harmony export */   Rectangle: () => (/* reexport safe */ _gameObjects_shapes_2d_Rectangle_js__WEBPACK_IMPORTED_MODULE_4__.Rectangle),\n/* harmony export */   SceneManager: () => (/* reexport safe */ _core_core_logic_SceneManager_js__WEBPACK_IMPORTED_MODULE_1__.SceneManager),\n/* harmony export */   TouchControl: () => (/* reexport safe */ _core_controls_touchControl_js__WEBPACK_IMPORTED_MODULE_9__.TouchControl),\n/* harmony export */   shape2d: () => (/* reexport safe */ _gameObjects_shapes_2d_shape_js__WEBPACK_IMPORTED_MODULE_6__.shape2d)\n/* harmony export */ });\n/* empty/unused harmony star reexport */\n/* harmony import */ var _core_core_logic_Core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/core_logic/Core.js */ \"./TETTE_CORE/core/core_logic/Core.js\");\n/* harmony import */ var _core_core_logic_SceneManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/core_logic/SceneManager.js */ \"./TETTE_CORE/core/core_logic/SceneManager.js\");\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module './core/core_logic/gameObject.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* harmony import */ var _core_core_logic_GraphicalContext_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/core_logic/GraphicalContext.js */ \"./TETTE_CORE/core/core_logic/GraphicalContext.js\");\n/* harmony import */ var _gameObjects_shapes_2d_Rectangle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gameObjects/shapes/2d/Rectangle.js */ \"./TETTE_CORE/gameObjects/shapes/2d/Rectangle.js\");\n/* harmony import */ var _gameObjects_shapes_2d_Circle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./gameObjects/shapes/2d/Circle.js */ \"./TETTE_CORE/gameObjects/shapes/2d/Circle.js\");\n/* harmony import */ var _gameObjects_shapes_2d_shape_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./gameObjects/shapes/2d/shape.js */ \"./TETTE_CORE/gameObjects/shapes/2d/shape.js\");\n/* harmony import */ var _core_controls_keyboardControl_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./core/controls/keyboardControl.js */ \"./TETTE_CORE/core/controls/keyboardControl.js\");\n/* harmony import */ var _core_controls_mouseControl_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./core/controls/mouseControl.js */ \"./TETTE_CORE/core/controls/mouseControl.js\");\n/* harmony import */ var _core_controls_touchControl_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./core/controls/touchControl.js */ \"./TETTE_CORE/core/controls/touchControl.js\");\n// TETTE_CORE/index.js\n\n// Экспортируем основные компоненты ядра\n\n\n\n\n\n// Экспортируем фигуры\n\n\n// export { Line } from './core/figures/Line.js';\n// export { Ellipse } from './core/figures/Ellipse.js';\n\n\n// Экспортируем контролы\n\n\n\n\n//# sourceURL=webpack://TETTE/./TETTE_CORE/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./TETTE_CORE/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});